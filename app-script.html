  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, onSnapshot, doc, getDoc, getDocs, setDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    let db, auth, currentUser;
    let employeesData = [];
    let unsubscribers = [];
    let librariesData = { offices: [], positions: [] };
    let employeeSearchTerms = { active: '', inactive: '' };
    let librarySearchTerms = { offices: '', positions: '' };

    // Helper to check if tab is currently visible
    function isTabVisible(tabId) {
      const tab = document.querySelector(`#${tabId}`);
      return tab && tab.classList.contains('show') && tab.classList.contains('active');
    }

    // Helper to format date as YYYY-MM-DD without timezone conversion
    function formatDateLocal(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    window.Modal = {
      _instance: null,
      _callback: null,

      _show(config) {
        const modalEl = document.getElementById('universalModal');
        const bodyEl = document.getElementById('universalModalBody');
        const footerEl = document.getElementById('universalModalFooter');

        // Detect if message contains HTML (starts with < or contains HTML tags)
        const isHtmlContent = config.message.trim().startsWith('<') || /<[a-z][\s\S]*>/i.test(config.message);

        // Use div for HTML content, p for plain text
        const messageWrapper = isHtmlContent
          ? `<div class="mb-0">${config.message}</div>`
          : `<p class="text-muted mb-0">${config.message}</p>`;

        bodyEl.innerHTML = `
          <div class="mb-3">
            <i class="bi ${config.icon} ${config.iconColor}" style="font-size: 4rem;"></i>
          </div>
          <h5 class="modal-title mb-3">${config.title}</h5>
          ${messageWrapper}
        `;

        footerEl.innerHTML = '';
        config.buttons.forEach(btn => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `btn ${btn.class} px-4`;
          button.textContent = btn.text;
          
          if (btn.dismiss) {
            button.setAttribute('data-bs-dismiss', 'modal');
          }
          
          if (btn.callback) {
            button.onclick = () => {
              if (this._instance) {
                this._instance.hide();
              }
              btn.callback();
            };
          } else if (btn.dismiss) {
          }
          
          footerEl.appendChild(button);
        });

        if (this._instance) {
          this._instance.dispose();
        }
        
        this._instance = new bootstrap.Modal(modalEl, {
          backdrop: config.backdrop !== false ? 'static' : true,
          keyboard: config.keyboard !== false
        });

        if (config.clickOutsideToClose) {
          modalEl.addEventListener('click', (e) => {
            if (e.target === modalEl) {
              this._instance.hide();
            }
          });
        }

        if (config.keyboard !== false) {
          const escHandler = (e) => {
            if (e.key === 'Escape' && this._instance) {
              this._instance.hide();
              modalEl.removeEventListener('keydown', escHandler);
            }
          };
          modalEl.addEventListener('keydown', escHandler);
        }

        this._instance.show();
      },

      success(title, message, callback) {
        this._show({
          title: title || 'Success!',
          message: message || '',
          icon: 'bi-check-circle-fill',
          iconColor: 'text-success',
          buttons: [
            { text: 'OK', class: 'btn-success', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      error(title, message, callback) {
        this._show({
          title: title || 'Error',
          message: message || '',
          icon: 'bi-x-circle-fill',
          iconColor: 'text-danger',
          buttons: [
            { text: 'OK', class: 'btn-danger', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      warning(title, message, callback) {
        this._show({
          title: title || 'Warning',
          message: message || '',
          icon: 'bi-exclamation-triangle-fill',
          iconColor: 'text-warning',
          buttons: [
            { text: 'OK', class: 'btn-warning', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      info(title, message, callback) {
        this._show({
          title: title || 'Information',
          message: message || '',
          icon: 'bi-info-circle-fill',
          iconColor: 'text-info',
          buttons: [
            { text: 'OK', class: 'btn-info', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      confirm(title, message, onConfirm, onCancel) {
        this._show({
          title: title || 'Confirm Action',
          message: message || 'Are you sure?',
          icon: 'bi-question-circle-fill',
          iconColor: 'text-warning',
          buttons: [
            { text: 'Cancel', class: 'btn-secondary', dismiss: true, callback: onCancel },
            { text: 'Yes, Continue', class: 'btn-warning', callback: onConfirm }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      custom(config) {
        const defaults = {
          title: 'Modal',
          message: '',
          icon: 'bi-info-circle-fill',
          iconColor: 'text-primary',
          buttons: [
            { text: 'OK', class: 'btn-primary', dismiss: true }
          ],
          keyboard: true,
          clickOutsideToClose: false,
          backdrop: true
        };
        
        const finalConfig = { ...defaults, ...config };
        this._show(finalConfig);
      }
    };

    async function initFirebase() {
      try {
        console.log('Starting Firebase initialization...');
        
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getFirebaseConfigAndToken();
        });

        console.log('Received Firebase config and token');
        
        const app = initializeApp(result.config);
        auth = getAuth(app);
        db = getFirestore(app);

        console.log('Signing in with custom token...');
        await signInWithCustomToken(auth, result.token);
        currentUser = auth.currentUser;
        
        console.log('Firebase authentication successful');
        document.getElementById('userEmail').innerHTML = `<i class="bi bi-person-circle"></i> ${result.userEmail}`;

        loadAllData();
      } catch (error) {
        console.error('Firebase init error:', error);
        Modal.error('Firebase Error', 'Error initializing Firebase: ' + error.message);
      }
    }

    function loadAllData() {
      loadEmployees();
      loadDashboard();
      loadHolidays();
      loadConfiguration();
      loadLibraries();
      // loadHistoricalBalances is now called when an employee is selected
    }

    function loadEmployees() {
      const q = query(collection(db, 'employees'), orderBy('lastName'));
      const unsubscribe = onSnapshot(q, (snapshot) => {
        employeesData = [];
        snapshot.forEach((doc) => {
          employeesData.push({ id: doc.id, ...doc.data() });
        });

        populateEmployeeDropdowns();
        // Only render the active tab initially for better performance
        renderEmployeesTable('active');
      });
      unsubscribers.push(unsubscribe);
    }

    function populateEmployeeDropdowns() {
      // Regular dropdowns (ledger, CTO, and CTO list filter)
      const dropdowns = ['ledger-employee', 'cto-employee', 'cto-list-employee'];
      dropdowns.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
          const placeholder = id === 'cto-list-employee' ? 'All Employees' : 'Select Employee';
          select.innerHTML = `<option value="">${placeholder}</option>`;
          employeesData.forEach(emp => {
            if (emp.isActive) {
              select.innerHTML += `<option value="${emp.employeeId}">${emp.lastName}, ${emp.firstName} (${emp.employeeId})</option>`;
            }
          });
        }
      });

      // Populate searchable dropdowns
      populateOvertimeEmployeeDropdown();
      populateCertEmployeeDropdown();
      populateHistoricalEmployeeDropdown();
      populateHistoricalEmployeeFilterDropdown();
      renderEmployeesWithoutHistoricalBalance();
    }

    function populateOvertimeEmployeeDropdown() {
      const dropdown = document.getElementById('ot-employee-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}', '${emp.office}', '${emp.position}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterOvertimeEmployees = function() {
      const searchInput = document.getElementById('ot-employee-search');
      const dropdown = document.getElementById('ot-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          const office = (emp.office || '').toLowerCase();
          const position = (emp.position || '').toLowerCase();

          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm) ||
                 office.includes(searchTerm) ||
                 position.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}', '${emp.office}', '${emp.position}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showOvertimeEmployeeDropdown();
    };

    window.showOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      dropdown.style.display = 'block';
    };

    window.hideOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      dropdown.style.display = 'none';
    };

    window.selectOvertimeEmployee = function(employeeId, name, office, position) {
      const searchInput = document.getElementById('ot-employee-search');
      const hiddenInput = document.getElementById('ot-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideOvertimeEmployeeDropdown();

      // Refresh month options for the selected employee
      updateOvertimeMonthOptions();
    };

    // Certificate Employee Dropdown Functions
    function populateCertEmployeeDropdown() {
      const dropdown = document.getElementById('cert-employee-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectCertEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterCertEmployees = function() {
      const searchInput = document.getElementById('cert-employee-search');
      const dropdown = document.getElementById('cert-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      if (!searchTerm) {
        populateCertEmployeeDropdown();
        return;
      }

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      const filtered = activeEmployees.filter(emp => {
        const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
        const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
        return fullName.includes(searchTerm) ||
               reverseName.includes(searchTerm) ||
               emp.employeeId.toLowerCase().includes(searchTerm) ||
               (emp.office && emp.office.toLowerCase().includes(searchTerm)) ||
               (emp.position && emp.position.toLowerCase().includes(searchTerm));
      });

      if (filtered.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filtered.map(emp => `
          <div class="dropdown-item-custom" onclick="selectCertEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showCertEmployeeDropdown();
    };

    window.showCertEmployeeDropdown = function() {
      const dropdown = document.getElementById('cert-employee-dropdown');
      dropdown.style.display = 'block';
    };

    window.hideCertEmployeeDropdown = function() {
      const dropdown = document.getElementById('cert-employee-dropdown');
      dropdown.style.display = 'none';
    };

    window.selectCertEmployee = function(employeeId, name) {
      const searchInput = document.getElementById('cert-employee-search');
      const hiddenInput = document.getElementById('cert-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideCertEmployeeDropdown();

      // Trigger loading uncertified months
      loadUncertifiedMonths();
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const otContainer = document.querySelector('.searchable-select-container');
      const otDropdown = document.getElementById('ot-employee-dropdown');
      const certDropdown = document.getElementById('cert-employee-dropdown');

      if (otContainer && otDropdown && !otContainer.contains(event.target)) {
        hideOvertimeEmployeeDropdown();
      }

      // Check if click is outside cert employee search
      const certSearch = document.getElementById('cert-employee-search');
      const certDropdownEl = document.getElementById('cert-employee-dropdown');
      if (certSearch && certDropdownEl &&
          !certSearch.contains(event.target) &&
          !certDropdownEl.contains(event.target)) {
        hideCertEmployeeDropdown();
      }
    });

    function renderEmployeesTable(type) {
      // If no type specified, render both (for initial load only)
      const typesToRender = type ? [type] : ['active', 'inactive'];

      typesToRender.forEach(tabType => {
        const employees = employeesData.filter(emp =>
          tabType === 'active' ? emp.isActive : !emp.isActive
        );

        // Apply search filter
        let filteredEmployees = employees;
        const searchTerm = employeeSearchTerms[tabType];

        if (searchTerm) {
          const searchLower = searchTerm.toLowerCase();
          filteredEmployees = employees.filter(emp => {
            const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
            const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
            return fullName.includes(searchLower) ||
                   reverseName.includes(searchLower) ||
                   (emp.office && emp.office.toLowerCase().includes(searchLower)) ||
                   (emp.position && emp.position.toLowerCase().includes(searchLower));
          });
        }

        const tableBody = document.getElementById(`${tabType}EmployeesTableBody`);

        if (filteredEmployees.length === 0) {
          const message = searchTerm ? 'No employees match your search' : `No ${tabType} employees found`;
          tableBody.innerHTML = `<tr><td colspan="5" class="text-center">${message}</td></tr>`;
        } else {
          tableBody.innerHTML = filteredEmployees.map(emp => `
            <tr>
              <td>${emp.employeeId}</td>
              <td>${emp.lastName}, ${emp.firstName}</td>
              <td>${emp.office}</td>
              <td>${emp.position}</td>
              <td>
                <button class="btn btn-sm btn-outline-primary me-1" onclick="editEmployee('${emp.employeeId}')">
                  <i class="bi bi-pencil"></i> Edit
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteEmployee('${emp.employeeId}')">
                  <i class="bi bi-trash"></i> Delete
                </button>
              </td>
            </tr>
          `).join('');
        }
      });
    }

    window.deleteEmployee = async function(employeeId) {
      Modal.confirm(
        'Delete Employee',
        'Are you sure you want to delete this employee? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteEmployee_SERVER(employeeId);
            });

            if (result.success) {
              Modal.success('Success!', 'Employee deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting employee: ' + error);
          }
        }
      );
    };

    window.filterEmployees = function(type) {
      const searchInput = document.getElementById(`search-${type}-employees`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      employeeSearchTerms[type] = searchInput.value;

      // Show/hide clear button
      if (searchInput.value) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }

      // Only render the specific tab being filtered
      renderEmployeesTable(type);
    };

    window.clearEmployeeSearch = function(type) {
      const searchInput = document.getElementById(`search-${type}-employees`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      searchInput.value = '';
      employeeSearchTerms[type] = '';
      clearBtn.classList.remove('visible');

      // Only render the specific tab being cleared
      renderEmployeesTable(type);
    };

    // Historical Balance Employee Dropdown Functions
    // Employee Filter Dropdown (Main selector)
    let selectedHistoricalEmployee = null;

    function populateHistoricalEmployeeFilterDropdown() {
      const dropdown = document.getElementById('hist-employee-filter-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterHistoricalEmployeeFilter = function() {
      const searchInput = document.getElementById('hist-employee-filter-search');
      const dropdown = document.getElementById('hist-employee-filter-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showHistoricalEmployeeFilterDropdown();
    };

    window.showHistoricalEmployeeFilterDropdown = function() {
      const dropdown = document.getElementById('hist-employee-filter-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideHistoricalEmployeeFilterDropdown = function() {
      const dropdown = document.getElementById('hist-employee-filter-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectHistoricalEmployeeFilter = function(employeeId, name) {
      const searchInput = document.getElementById('hist-employee-filter-search');
      const hiddenInput = document.getElementById('hist-employee-filter');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;
      selectedHistoricalEmployee = employeeId;

      hideHistoricalEmployeeFilterDropdown();

      // Show content section and pre-fill form
      document.getElementById('hist-content-section').style.display = 'block';
      document.getElementById('hist-employee-name').value = `${name} (${employeeId})`;
      document.getElementById('hist-employee').value = employeeId;

      // Activate the "Add Historical Balance" tab as default
      const addTab = document.getElementById('tab-add-hist');
      if (addTab) {
        addTab.click();
      }

      // Load historical balances for this employee
      loadHistoricalBalances();

      // Check if employee has overtime logs and disable historical balance actions
      checkEmployeeHasOvertimeLogs(employeeId);
    };

    async function checkEmployeeHasOvertimeLogs(employeeId) {
      const formCard = document.querySelector('#content-add-hist .card-body');

      try {
        // Show loading indicator immediately
        const loadingHTML = `
          <div class="alert alert-info hist-check-loading">
            <div class="spinner-border spinner-border-sm me-2" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            Checking employee overtime history...
          </div>
        `;
        if (formCard && !formCard.querySelector('.hist-check-loading')) {
          formCard.insertAdjacentHTML('afterbegin', loadingHTML);
        }

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .checkEmployeeHasOvertimeLogs_SERVER(employeeId);
        });

        // Remove loading indicator
        const loading = document.querySelector('.hist-check-loading');
        if (loading) loading.remove();

        if (result.hasLogs) {
          // Disable form fields
          document.getElementById('hist-month-year').disabled = true;
          document.getElementById('hist-date-issuance').disabled = true;
          document.getElementById('hist-coc-earned').disabled = true;
          document.getElementById('hist-coc-used').disabled = true;
          document.getElementById('hist-submit-btn').disabled = true;

          // Show warning message
          const warningHTML = `
            <div class="alert alert-warning">
              <i class="bi bi-exclamation-triangle-fill"></i>
              <strong>Historical Balance Locked:</strong> This employee has already logged overtime.
              Historical balance cannot be added or modified to prevent data inconsistency.
            </div>
          `;
          if (formCard && !formCard.querySelector('.alert-warning')) {
            formCard.insertAdjacentHTML('afterbegin', warningHTML);
          }
        } else {
          // Enable form fields
          document.getElementById('hist-month-year').disabled = false;
          document.getElementById('hist-coc-earned').disabled = false;
          document.getElementById('hist-coc-used').disabled = false;
          document.getElementById('hist-submit-btn').disabled = false;

          // Remove warning if exists
          const warning = document.querySelector('#content-add-hist .alert-warning');
          if (warning) warning.remove();
        }

        // Return the result for use in rendering table
        return result.hasLogs;
      } catch (error) {
        console.error('Error checking overtime logs:', error);

        // Remove loading indicator on error
        const loading = document.querySelector('.hist-check-loading');
        if (loading) loading.remove();

        return false;
      }
    }

    function renderEmployeesWithoutHistoricalBalance() {
      const container = document.getElementById('employees-no-hist-list');
      if (!container) return;

      // Get all active employees
      const activeEmployees = employeesData.filter(emp => emp.isActive);

      // Get employees with historical balance (from Firestore)
      const db = getFirestore();
      const q = query(
        collection(db, 'creditBatches'),
        where('source', '==', 'Historical')
      );

      onSnapshot(q, (snapshot) => {
        const employeesWithHist = new Set();
        snapshot.forEach(doc => {
          const batch = doc.data();
          employeesWithHist.add(batch.employeeId);
        });

        const employeesWithoutHist = activeEmployees.filter(emp =>
          !employeesWithHist.has(emp.employeeId)
        );

        if (employeesWithoutHist.length === 0) {
          container.innerHTML = '<span class="text-success"><i class="bi bi-check-circle-fill"></i> All active employees have historical balance migrated!</span>';
        } else {
          container.innerHTML = employeesWithoutHist.map(emp => `
            <span class="badge bg-warning text-dark" style="cursor: pointer;"
                  onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')"
                  title="Click to add historical balance for this employee">
              ${emp.lastName}, ${emp.firstName} (${emp.employeeId})
            </span>
          `).join('');
        }
      });
    }

    // Click outside to close dropdown
    document.addEventListener('click', function(e) {
      const container = document.querySelector('#hist-employee-filter-search')?.closest('.searchable-select-container');
      if (container && !container.contains(e.target)) {
        hideHistoricalEmployeeFilterDropdown();
      }
    });

    function populateHistoricalEmployeeDropdown() {
      const dropdown = document.getElementById('hist-employee-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectHistoricalEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterHistoricalEmployees = function() {
      const searchInput = document.getElementById('hist-employee-search');
      const dropdown = document.getElementById('hist-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectHistoricalEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showHistoricalEmployeeDropdown();
    };

    window.showHistoricalEmployeeDropdown = function() {
      const dropdown = document.getElementById('hist-employee-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideHistoricalEmployeeDropdown = function() {
      const dropdown = document.getElementById('hist-employee-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectHistoricalEmployee = function(employeeId, name) {
      const searchInput = document.getElementById('hist-employee-search');
      const hiddenInput = document.getElementById('hist-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideHistoricalEmployeeDropdown();
    };

    // Enable Date of Issuance when Month & Year is selected
    window.enableDateOfIssuance = function() {
      const monthYear = document.getElementById('hist-month-year').value;
      const dateIssuance = document.getElementById('hist-date-issuance');

      if (monthYear) {
        dateIssuance.disabled = false;

        // Set min and max dates based on the selected month
        const [year, month] = monthYear.split('-');
        const earnedYear = parseInt(year);
        const earnedMonth = parseInt(month);

        // Helper function to format date as YYYY-MM-DD without timezone issues
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };

        // Min: Last day of earned month (e.g., Jan 31, 2024 for January 2024)
        const lastDayOfEarnedMonth = new Date(earnedYear, earnedMonth, 0);
        const minDate = formatDate(lastDayOfEarnedMonth);

        // Max: Last day of the month AFTER the earned month
        // (e.g., Feb 29, 2024 for January 2024, or Jan 31, 2025 for December 2024)
        const lastDayOfNextMonth = new Date(earnedYear, earnedMonth + 1, 0);
        const maxDate = formatDate(lastDayOfNextMonth);

        // Default: 1st day of the month AFTER the earned month
        // (e.g., Feb 1, 2024 for January 2024, or Jan 1, 2025 for December 2024)
        const firstDayOfNextMonth = new Date(earnedYear, earnedMonth, 1);
        const defaultDate = formatDate(firstDayOfNextMonth);

        dateIssuance.min = minDate;
        dateIssuance.max = maxDate;

        // Set default value to the 1st day of the month AFTER the earned month
        dateIssuance.value = defaultDate;
      } else {
        dateIssuance.disabled = true;
        dateIssuance.value = '';
      }

      validateHistoricalFields();
    };

    // Live validation for Historical Balance fields
    window.validateHistoricalFields = function() {
      const earnedInput = document.getElementById('hist-coc-earned');
      const usedInput = document.getElementById('hist-coc-used');
      const earnedValue = parseFloat(earnedInput.value) || 0;
      const usedValue = parseFloat(usedInput.value) || 0;

      // Validate COC Earned (max 40)
      if (earnedValue > 40) {
        earnedInput.classList.add('is-invalid');
        document.getElementById('hist-earned-feedback').textContent = 'Cannot exceed 40 hours per month';
      } else if (earnedValue < 0) {
        earnedInput.classList.add('is-invalid');
        document.getElementById('hist-earned-feedback').textContent = 'Must be a positive number';
      } else {
        earnedInput.classList.remove('is-invalid');
      }

      // Validate COC Used (must be in blocks of 4 or 8, and <= earned)
      if (usedValue > earnedValue) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Cannot exceed COC Earned';
      } else if (usedValue > 0 && usedValue % 4 !== 0) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Must be in blocks of 4 hours (4, 8, 12, 16, etc.)';
      } else if (usedValue < 0) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Must be a positive number';
      } else {
        usedInput.classList.remove('is-invalid');
      }

      // Update auto-calculated fields
      calculateHistoricalRemaining();
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const histContainer = document.querySelector('#hist-employee-dropdown')?.parentElement;
      const histDropdown = document.getElementById('hist-employee-dropdown');

      if (histContainer && histDropdown && !histContainer.contains(event.target)) {
        hideHistoricalEmployeeDropdown();
      }
    });

    async function loadDashboard() {
      const batchesQ = query(collection(db, 'creditBatches'), where('status', '==', 'Active'));
      const logsQ = query(collection(db, 'overtimeLogs'), where('status', '==', 'Uncertified'));

      onSnapshot(batchesQ, (snapshot) => {
        let totalLiability = 0;
        let expiringSoon = 0;
        const today = new Date();
        const thirtyDays = new Date(today);
        thirtyDays.setDate(today.getDate() + 30);

        snapshot.forEach((doc) => {
          const batch = doc.data();
          totalLiability += batch.remainingHours;
          const expiryDate = new Date(batch.expiryDate);
          if (expiryDate <= thirtyDays) {
            expiringSoon += batch.remainingHours;
          }
        });

        document.getElementById('stat-total-liability').textContent = totalLiability.toFixed(2);
        document.getElementById('stat-expiring-soon').textContent = expiringSoon.toFixed(2);
        
        renderAlerts(expiringSoon, snapshot.docs.length);
      });

      onSnapshot(logsQ, (snapshot) => {
        document.getElementById('stat-uncertified').textContent = snapshot.size;
      });

      const empQ = query(collection(db, 'employees'), where('isActive', '==', true));
      onSnapshot(empQ, (snapshot) => {
        document.getElementById('stat-active-employees').textContent = snapshot.size;
      });
    }

    function renderAlerts(expiringSoon, totalBatches) {
      const container = document.getElementById('alerts-container');
      let html = '';

      if (expiringSoon > 0) {
        html += `
          <div class="alert-item warning">
            <i class="bi bi-exclamation-triangle-fill"></i>
            <strong>Expiring Credits:</strong> ${expiringSoon.toFixed(2)} hours will expire in the next 30 days
            <button class="btn btn-sm btn-outline-warning ms-2" onclick="viewExpiringCreditsDetails()">
              <i class="bi bi-eye"></i> View Details
            </button>
          </div>
        `;
      }

      if (totalBatches > 50) {
        html += `
          <div class="alert-item info">
            <i class="bi bi-info-circle-fill"></i>
            <strong>Active Batches:</strong> There are ${totalBatches} active credit batches in the system
          </div>
        `;
      }

      if (html === '') {
        html = '<p class="text-muted">No alerts at this time</p>';
      }

      container.innerHTML = html;
    }

    window.viewExpiringCreditsDetails = async function() {
      const modal = new bootstrap.Modal(document.getElementById('expiringCreditsModal'));
      const modalBody = document.getElementById('expiringCreditsModalBody');
      const modalTotal = document.getElementById('expiringCreditsModalTotal');

      modalBody.innerHTML = '<tr><td colspan="5" class="text-center">Loading...</td></tr>';
      modal.show();

      try {
        const today = new Date();
        const thirtyDays = new Date(today);
        thirtyDays.setDate(today.getDate() + 30);

        // Query all active credit batches
        const batchesQ = query(
          collection(db, 'creditBatches'),
          where('status', '==', 'Active')
        );

        const snapshot = await getDocs(batchesQ);

        // Fetch employee data to get names and offices
        const employeesSnapshot = await getDocs(collection(db, 'employees'));
        const employeesMap = {};
        employeesSnapshot.forEach(doc => {
          employeesMap[doc.id] = doc.data();
        });

        // Build array of expiring batches with employee details (filter in memory)
        const expiringBatches = [];
        let totalExpiring = 0;

        snapshot.forEach(doc => {
          const batch = doc.data();
          const expiryDate = new Date(batch.expiryDate);

          // Only include batches expiring within 30 days
          if (expiryDate <= thirtyDays) {
            const employee = employeesMap[batch.employeeId];

            expiringBatches.push({
              employeeName: employee ? `${employee.firstName} ${employee.lastName}` : 'Unknown',
              office: employee ? employee.office : 'N/A',
              earnedPeriod: `${getMonthName(batch.earnedMonth)} ${batch.earnedYear}`,
              expiryDate: expiryDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }),
              expiryDateSort: expiryDate,
              remainingHours: batch.remainingHours
            });

            totalExpiring += batch.remainingHours;
          }
        });

        if (expiringBatches.length === 0) {
          modalBody.innerHTML = '<tr><td colspan="5" class="text-center text-muted">No expiring credits found</td></tr>';
          modalTotal.textContent = '0.0';
          return;
        }

        // Sort by expiry date (earliest first)
        expiringBatches.sort((a, b) => a.expiryDateSort - b.expiryDateSort);

        // Render table
        modalBody.innerHTML = expiringBatches.map(batch => `
          <tr>
            <td>${batch.employeeName}</td>
            <td>${batch.office}</td>
            <td>${batch.earnedPeriod}</td>
            <td><span class="badge bg-danger">${batch.expiryDate}</span></td>
            <td><strong>${batch.remainingHours.toFixed(1)}</strong> hrs</td>
          </tr>
        `).join('');

        modalTotal.textContent = totalExpiring.toFixed(1);

      } catch (error) {
        console.error('Error loading expiring credits:', error);
        modalBody.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading data</td></tr>';
      }
    };

    function getMonthName(monthIndex) {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return months[monthIndex];
    }

    function loadHolidays() {
      const q = query(collection(db, 'holidays'), orderBy('date', 'desc'));
      onSnapshot(q, (snapshot) => {
        const tbody = document.getElementById('holidaysTableBody');
        if (snapshot.empty) {
          tbody.innerHTML = '<tr><td colspan="5" class="text-center">No holidays found</td></tr>';
          return;
        }

        tbody.innerHTML = snapshot.docs.map(doc => {
          const hol = doc.data();
          const date = new Date(hol.date);
          return `
            <tr>
              <td>${date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td>
              <td>${hol.name}</td>
              <td><span class="badge ${hol.type === 'Regular' ? 'bg-danger' : 'bg-warning'}">${hol.type}</span></td>
              <td>${hol.isRecurring ? 'Yes' : 'No'}</td>
              <td>
                <button class="btn btn-sm btn-outline-primary me-1" onclick="editHoliday('${doc.id}')">
                  <i class="bi bi-pencil"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteHoliday('${doc.id}')">
                  <i class="bi bi-trash"></i>
                </button>
              </td>
            </tr>
          `;
        }).join('');
      });
    }

    function loadConfiguration() {
      console.log('Loading configuration from Firestore...');
      
      const configRef = doc(db, 'configuration', 'accrualRules');
      
      const unsubscribe = onSnapshot(configRef, 
        (docSnap) => {
          console.log('Configuration snapshot received');
          
          if (docSnap.exists()) {
            const config = docSnap.data();
            console.log('Configuration data:', config);
            
            document.getElementById('config-regular').value = config.regularDayMultiplier ?? 1.25;
            document.getElementById('config-restday').value = config.restDayMultiplier ?? 1.30;
            document.getElementById('config-holiday').value = config.holidayMultiplier ?? 2.00;
            document.getElementById('config-monthly-cap').value = config.monthlyAccrualCap ?? 40;
            document.getElementById('config-total-cap').value = config.totalBalanceCap ?? 120;
            document.getElementById('config-expiry-months').value = config.expiryMonths ?? 12;
            
            console.log('Configuration loaded successfully');
          } else {
            console.error('Configuration document does not exist');
          }
        },
        (error) => {
          console.error('Error loading configuration:', error);
        }
      );
      
      unsubscribers.push(unsubscribe);
    }

    function loadLibraries() {
      ['offices', 'positions'].forEach(libType => {
        const q = query(collection(db, 'libraries', libType, 'items'), orderBy('name'));
        onSnapshot(q, (snapshot) => {
          // Store library data for filtering
          librariesData[libType] = [];
          snapshot.forEach((doc) => {
            librariesData[libType].push({ id: doc.id, ...doc.data() });
          });

          // Only render the offices tab initially for better performance
          // Positions tab will be rendered when user switches to it
          if (libType === 'offices') {
            renderLibraryTable(libType);
          }
          populateLibraryDropdowns(libType, snapshot.docs);
        });
      });
    }

    function renderLibraryTable(libType) {
      const container = document.getElementById(`${libType}-list`);
      let items = librariesData[libType];

      // Apply search filter
      if (librarySearchTerms[libType]) {
        items = items.filter(item => {
          const searchLower = librarySearchTerms[libType].toLowerCase();
          return item.name.toLowerCase().includes(searchLower);
        });
      }

      if (items.length === 0) {
        const message = librarySearchTerms[libType] ? 'No items match your search' : 'No items found';
        container.innerHTML = `<tr><td colspan="2" class="text-center text-muted">${message}</td></tr>`;
        return;
      }

      container.innerHTML = items.map(item => {
        return `
          <tr>
            <td>${item.name}</td>
            <td>
              <button class="btn btn-sm btn-outline-primary me-1" onclick="editLibraryItem('${libType}', '${item.id}', '${item.name}')">
                <i class="bi bi-pencil"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger" onclick="deleteLibraryItem('${libType}', '${item.id}', '${item.name}')">
                <i class="bi bi-trash"></i>
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    window.filterLibrary = function(type) {
      const searchInput = document.getElementById(`search-${type}`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      librarySearchTerms[type] = searchInput.value;

      // Show/hide clear button
      if (searchInput.value) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }

      renderLibraryTable(type);
    };

    window.clearLibrarySearch = function(type) {
      const searchInput = document.getElementById(`search-${type}`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      searchInput.value = '';
      librarySearchTerms[type] = '';
      clearBtn.classList.remove('visible');

      renderLibraryTable(type);
    };

    function populateLibraryDropdowns(libType, docs) {
      const selectId = libType === 'offices' ? 'emp-office' : 'emp-position';
      const select = document.getElementById(selectId);
      select.innerHTML = '<option value="">Select</option>';
      docs.forEach(doc => {
        const item = doc.data();
        select.innerHTML += `<option value="${item.name}">${item.name}</option>`;
      });
    }

    // ========== GENERATE CERTIFICATE FEATURE ==========

    // Month names array for display
    const certMonthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                            'July', 'August', 'September', 'October', 'November', 'December'];

    // Initialize certificate batch year dropdown
    (function initializeCertBatchYearDropdown() {
      const yearSelect = document.getElementById('cert-batch-year');
      const currentYear = new Date().getFullYear();
      for (let i = 0; i <= 2; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
      }
    })();

    // Tab 1: By Employee - Load uncertified months
    // Debounce timer to prevent too many rapid calls
    let loadUncertifiedMonthsTimer = null;
    let lastLoadedEmployeeId = null;
    let cachedUncertifiedResult = null;

    window.loadUncertifiedMonths = async function() {
      const employeeId = document.getElementById('cert-employee').value;
      const tableSection = document.getElementById('cert-employee-table-section');
      const tbody = document.getElementById('cert-months-tbody');
      const loadingDiv = document.getElementById('cert-employee-loading');

      if (!employeeId) {
        tableSection.style.display = 'none';
        loadingDiv.style.display = 'none';
        return;
      }

      // Use cached result if same employee
      if (lastLoadedEmployeeId === employeeId && cachedUncertifiedResult) {
        renderUncertifiedMonths(cachedUncertifiedResult, tbody, tableSection, loadingDiv, employeeId);
        return;
      }

      // Clear any pending timer
      if (loadUncertifiedMonthsTimer) {
        clearTimeout(loadUncertifiedMonthsTimer);
      }

      // Debounce: wait 300ms before making the call
      loadUncertifiedMonthsTimer = setTimeout(async () => {
        try {
          // Show loading spinner
          loadingDiv.style.display = 'block';
          tableSection.style.display = 'none';

          const result = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getUncertifiedMonthsByEmployee_SERVER(employeeId);
          });

          // Cache the result
          lastLoadedEmployeeId = employeeId;
          cachedUncertifiedResult = result;

          renderUncertifiedMonths(result, tbody, tableSection, loadingDiv, employeeId);

        } catch (error) {
          loadingDiv.style.display = 'none';

          // Better error handling for rate limits
          if (error.message && error.message.includes('429')) {
            Modal.error('Too Many Requests', 'Please wait a moment and try again. The system is currently rate-limited.');
          } else {
            Modal.error('Error', 'Failed to load uncertified months: ' + error);
          }
        }
      }, 300); // 300ms debounce
    };

    // Helper function to render uncertified months
    function renderUncertifiedMonths(result, tbody, tableSection, loadingDiv, employeeId) {
      // Hide loading spinner and re-enable fields
      loadingDiv.style.display = 'none';
      document.getElementById('cert-batch-month').disabled = false;
      document.getElementById('cert-batch-year').disabled = false;
      document.getElementById('cert-batch-load-btn').disabled = false;

      if (result.success && result.months.length > 0) {
        tbody.innerHTML = result.months.map(month => `
          <tr>
            <td>${certMonthNames[month.month]} ${month.year}</td>
            <td>${month.entries.length}</td>
            <td><strong>${month.totalHours.toFixed(1)}</strong> hrs</td>
            <td>
              <button class="btn btn-sm btn-outline-primary me-1" onclick="viewMonthEntries('${employeeId}', ${month.month}, ${month.year})">
                <i class="bi bi-eye"></i> View
              </button>
              <button class="btn btn-sm btn-success" onclick="openGenerateCertModal('${employeeId}', ${month.month}, ${month.year}, ${month.totalHours}, ${month.entries.length})">
                <i class="bi bi-file-earmark-check"></i> Generate
              </button>
            </td>
          </tr>
        `).join('');
        tableSection.style.display = 'block';
      } else {
        tbody.innerHTML = '<tr><td colspan="4" class="text-center">No uncertified overtime logs</td></tr>';
        tableSection.style.display = 'block';
      }
    }

    // View entries modal
    window.viewMonthEntries = async function(employeeId, month, year) {
      const modal = new bootstrap.Modal(document.getElementById('viewEntriesModal'));
      const modalTitle = document.getElementById('viewEntriesModalTitle');
      const modalBody = document.getElementById('viewEntriesModalBody');
      const modalTotal = document.getElementById('viewEntriesModalTotal');

      modalTitle.textContent = `${certMonthNames[month]} ${year} - Overtime Entries`;
      modalBody.innerHTML = '<tr><td colspan="8" class="text-center">Loading...</td></tr>';
      modal.show();

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getUncertifiedMonthsByEmployee_SERVER(employeeId);
        });

        if (result.success) {
          const monthData = result.months.find(m => m.month === month && m.year === year);
          if (monthData) {
            modalBody.innerHTML = monthData.entries.map(entry => {
              const date = new Date(entry.overtimeDate);
              return `
                <tr>
                  <td>${date.toLocaleDateString('en-US')}</td>
                  <td><span class="badge ${entry.isHoliday ? 'bg-danger' : entry.dayType === 'weekend' ? 'bg-warning' : 'bg-primary'}">${entry.isHoliday ? entry.holidayName : entry.dayType}</span></td>
                  <td>${entry.amIn || '-'}</td>
                  <td>${entry.amOut || '-'}</td>
                  <td>${entry.pmIn || '-'}</td>
                  <td>${entry.pmOut || '-'}</td>
                  <td>${entry.hoursWorked.toFixed(1)}</td>
                  <td><strong>${entry.earnedHours.toFixed(1)}</strong></td>
                </tr>
              `;
            }).join('');
            modalTotal.textContent = monthData.totalHours.toFixed(1);
          }
        }
      } catch (error) {
        modalBody.innerHTML = '<tr><td colspan="8" class="text-center text-danger">Error loading entries</td></tr>';
      }
    };

    // Open generate certificate modal
    window.openGenerateCertModal = function(employeeId, month, year, totalHours, entriesCount) {
      document.getElementById('gen-cert-employee-id').value = employeeId;
      document.getElementById('gen-cert-month').value = month;
      document.getElementById('gen-cert-year').value = year;
      document.getElementById('gen-cert-month-display').textContent = `${certMonthNames[month]} ${year}`;
      document.getElementById('gen-cert-hours-display').textContent = `${totalHours.toFixed(1)} hours`;
      document.getElementById('gen-cert-entries-display').textContent = entriesCount;
      document.getElementById('gen-cert-date-of-issuance').value = '';
      document.getElementById('gen-cert-valid-until').value = '';

      // Calculate valid date range: last day of earned month to last day of following month
      // month is 0-based (0=Jan, 1=Feb, etc.)
      const lastDayOfMonth = new Date(year, month + 1, 0); // Last day of the earned month
      const followingMonth = month === 11 ? 0 : month + 1; // 11=December -> 0=January
      const followingYear = month === 11 ? year + 1 : year;
      const lastDayOfFollowingMonth = new Date(followingYear, followingMonth + 1, 0);

      // Format dates for input min/max (YYYY-MM-DD)
      const minDate = formatDateLocal(lastDayOfMonth);
      const maxDate = formatDateLocal(lastDayOfFollowingMonth);

      // Set min/max and enable the date input
      const dateInput = document.getElementById('gen-cert-date-of-issuance');
      dateInput.min = minDate;
      dateInput.max = maxDate;
      dateInput.disabled = false;

      // Auto-populate with 1st day of following month
      const firstDayOfFollowingMonth = new Date(followingYear, followingMonth, 1);
      const defaultDate = formatDateLocal(firstDayOfFollowingMonth);
      dateInput.value = defaultDate;

      // Trigger Valid Until calculation
      updateGenCertValidUntil();

      // Update help text to show valid range
      const helpText = dateInput.nextElementSibling;
      helpText.textContent = `Should be from ${lastDayOfMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} to ${lastDayOfFollowingMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;

      const modal = new bootstrap.Modal(document.getElementById('generateCertModal'));
      modal.show();
    };

    // Update Valid Until when Date of Issuance changes
    window.updateGenCertValidUntil = function() {
      const dateOfIssuance = document.getElementById('gen-cert-date-of-issuance').value;
      if (dateOfIssuance) {
        const date = new Date(dateOfIssuance);
        date.setFullYear(date.getFullYear() + 1);
        date.setDate(date.getDate() - 1); // Subtract 1 day (1 year minus 1 day)
        document.getElementById('gen-cert-valid-until').value = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
      }
    };

    // Submit generate certificate
    window.submitGenerateCertificate = async function() {
      const employeeId = document.getElementById('gen-cert-employee-id').value;
      const month = parseInt(document.getElementById('gen-cert-month').value);
      const year = parseInt(document.getElementById('gen-cert-year').value);
      const dateOfIssuance = document.getElementById('gen-cert-date-of-issuance').value;

      if (!dateOfIssuance) {
        Modal.error('Validation Error', 'Please select Date of Issuance');
        return;
      }

      // Show loading spinner and disable buttons
      const submitBtn = document.getElementById('gen-cert-submit-btn');
      const cancelBtn = document.getElementById('gen-cert-cancel-btn');
      const submitText = document.getElementById('gen-cert-submit-text');
      const submitSpinner = document.getElementById('gen-cert-submit-spinner');

      submitBtn.disabled = true;
      cancelBtn.disabled = true;
      submitText.style.display = 'none';
      submitSpinner.style.display = 'inline';

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .generateCOCCertificate_SERVER({
              employeeId: employeeId,
              month: month,
              year: year,
              dateOfIssuance: dateOfIssuance
            });
        });

        // Hide loading spinner and enable buttons
        submitBtn.disabled = false;
        cancelBtn.disabled = false;
        submitText.style.display = 'inline';
        submitSpinner.style.display = 'none';

        if (result.success) {
          bootstrap.Modal.getInstance(document.getElementById('generateCertModal')).hide();

          let message = `
            <div class="text-center">
              <table class="table table-bordered mt-3 text-start mx-auto" style="max-width: 500px;">
                <tbody>
                  <tr>
                    <td style="width: 40%;"><strong>Certificate ID</strong></td>
                    <td><code>${result.certificateId}</code></td>
                  </tr>
                  <tr>
                    <td><strong>Period</strong></td>
                    <td>${result.monthYear}</td>
                  </tr>
                  <tr>
                    <td><strong>Total Hours</strong></td>
                    <td><strong class="text-primary">${result.totalEarnedHours.toFixed(1)}</strong> hours</td>
                  </tr>`;

          // PDF Certificate row (always present since PDF is required for success)
          message += `
                  <tr>
                    <td><strong>Certificate</strong></td>
                    <td>
                      <a href="${result.pdfUrl}" target="_blank" class="btn btn-sm btn-primary">
                        <i class="bi bi-file-pdf"></i> View/Download
                      </a>
                    </td>
                  </tr>`;

          // Summary PDF row
          if (result.summaryPdfUrl) {
            message += `
                  <tr>
                    <td><strong>Overtime Summary</strong></td>
                    <td>
                      <a href="${result.summaryPdfUrl}" target="_blank" class="btn btn-sm btn-success">
                        <i class="bi bi-file-pdf"></i> View/Download
                      </a>
                    </td>
                  </tr>`;
          }

          message += `
                </tbody>
              </table>
            </div>`;

          Modal.success('Certificate Generated Successfully!', message);

          // Reload the list
          loadUncertifiedMonths();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        // Hide loading spinner and enable buttons on error
        submitBtn.disabled = false;
        cancelBtn.disabled = false;
        submitText.style.display = 'inline';
        submitSpinner.style.display = 'none';

        Modal.error('Error', 'Failed to generate certificate: ' + error);
      }
    };

    // Reset batch form when month/year changes
    window.resetBatchForm = function() {
      const tableSection = document.getElementById('cert-batch-table-section');
      const batchDateInput = document.getElementById('cert-batch-date-of-issuance');
      const validUntilInput = document.getElementById('cert-batch-valid-until');
      const selectAllCheckbox = document.getElementById('cert-batch-select-all');

      // Check if there's any form progress
      const hasData = tableSection.style.display !== 'none' ||
                      batchDateInput.value ||
                      validUntilInput.value ||
                      (selectAllCheckbox && selectAllCheckbox.checked);

      if (hasData) {
        // Show confirmation before resetting
        Modal.confirm(
          'Reset Form',
          'Changing the month or year will reset the form and clear your selections. Do you want to continue?',
          function() {
            // User confirmed - reset the form
            performBatchReset();
          },
          function() {
            // User cancelled - revert the month/year selections
            // This is tricky since we don't know the previous values
            // For now, just don't reset
          }
        );
      } else {
        // No data, safe to reset
        performBatchReset();
      }
    };

    function performBatchReset() {
      const tableSection = document.getElementById('cert-batch-table-section');
      const noEmployeesDiv = document.getElementById('cert-batch-no-employees');
      const tbody = document.getElementById('cert-batch-tbody');
      const batchDateInput = document.getElementById('cert-batch-date-of-issuance');
      const validUntilInput = document.getElementById('cert-batch-valid-until');
      const selectAllCheckbox = document.getElementById('cert-batch-select-all');
      const helpText = document.getElementById('cert-batch-date-help');

      // Reset table and message
      tableSection.style.display = 'none';
      noEmployeesDiv.style.display = 'none';
      tbody.innerHTML = '<tr><td colspan="6" class="text-center">Select month and year, then click Load</td></tr>';

      // Reset date inputs
      batchDateInput.value = '';
      batchDateInput.disabled = true;
      batchDateInput.min = '';
      batchDateInput.max = '';
      validUntilInput.value = '';

      // Reset checkbox
      if (selectAllCheckbox) selectAllCheckbox.checked = false;

      // Reset help text
      if (helpText) helpText.textContent = 'Select month & year above to enable';

      // Reset summary
      document.getElementById('cert-batch-selected-count').textContent = '0';
      document.getElementById('cert-batch-total-hours').textContent = '0.0';
    }

    // Tab 2: Batch - Load employees by month
    window.loadBatchEmployees = async function() {
      const month = document.getElementById('cert-batch-month').value;
      const year = document.getElementById('cert-batch-year').value;
      const tableSection = document.getElementById('cert-batch-table-section');
      const noEmployeesDiv = document.getElementById('cert-batch-no-employees');
      const tbody = document.getElementById('cert-batch-tbody');
      const loadingDiv = document.getElementById('cert-batch-loading');

      if (month === '' || !year) {
        Modal.error('Validation Error', 'Please select both month and year');
        return;
      }

      try {
        // Disable month, year, and load button
        document.getElementById('cert-batch-month').disabled = true;
        document.getElementById('cert-batch-year').disabled = true;
        document.getElementById('cert-batch-load-btn').disabled = true;

        // Show loading spinner, hide table and message
        loadingDiv.style.display = 'block';
        tableSection.style.display = 'none';
        noEmployeesDiv.style.display = 'none';

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getEmployeesByMonthWithUncertified_SERVER(parseInt(month), parseInt(year));
        });

        // Hide loading spinner and re-enable fields
        loadingDiv.style.display = 'none';
        document.getElementById('cert-batch-month').disabled = false;
        document.getElementById('cert-batch-year').disabled = false;
        document.getElementById('cert-batch-load-btn').disabled = false;

        if (result.success && result.employees.length > 0) {
          tbody.innerHTML = result.employees.map(emp => `
            <tr>
              <td><input type="checkbox" class="batch-emp-checkbox" data-employeeid="${emp.employeeId}" onchange="updateBatchSummary()"></td>
              <td>${emp.fullName}</td>
              <td>${emp.office}</td>
              <td><strong>${emp.totalHours.toFixed(1)}</strong> hrs</td>
              <td>${emp.entriesCount}</td>
              <td>
                <button class="btn btn-sm btn-outline-primary" onclick="viewMonthEntries('${emp.employeeId}', ${month}, ${year})">
                  <i class="bi bi-eye"></i> View
                </button>
              </td>
            </tr>
          `).join('');
          tableSection.style.display = 'block';
          noEmployeesDiv.style.display = 'none';
          updateBatchSummary();

          // Calculate valid date range and enable Date of Issuance field
          // month is 0-based (0=Jan, 1=Feb, etc.)
          const selectedMonth = parseInt(month);
          const selectedYear = parseInt(year);
          const lastDayOfMonth = new Date(selectedYear, selectedMonth + 1, 0); // Last day of the earned month
          const followingMonth = selectedMonth === 11 ? 0 : selectedMonth + 1; // 11=December -> 0=January
          const followingYear = selectedMonth === 11 ? selectedYear + 1 : selectedYear;
          const lastDayOfFollowingMonth = new Date(followingYear, followingMonth + 1, 0);

          // Format dates for input min/max (YYYY-MM-DD)
          const minDate = formatDateLocal(lastDayOfMonth);
          const maxDate = formatDateLocal(lastDayOfFollowingMonth);

          // Enable and set min/max on batch date input
          const batchDateInput = document.getElementById('cert-batch-date-of-issuance');
          batchDateInput.min = minDate;
          batchDateInput.max = maxDate;
          batchDateInput.disabled = false;

          // Auto-populate with 1st day of following month
          const firstDayOfFollowingMonth = new Date(followingYear, followingMonth, 1);
          const defaultDate = formatDateLocal(firstDayOfFollowingMonth);
          batchDateInput.value = defaultDate;

          // Trigger Valid Until calculation
          updateBatchValidUntil();

          // Update help text
          const helpText = document.getElementById('cert-batch-date-help');
          helpText.textContent = `Should be from ${lastDayOfMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} to ${lastDayOfFollowingMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
        } else {
          // No employees found - show message
          tableSection.style.display = 'none';
          noEmployeesDiv.style.display = 'block';
        }

      } catch (error) {
        loadingDiv.style.display = 'none';
        Modal.error('Error', 'Failed to load employees: ' + error);
      }
    };

    // Toggle batch select all
    window.toggleBatchSelectAll = function() {
      const selectAll = document.getElementById('cert-batch-select-all');
      const checkboxes = document.querySelectorAll('.batch-emp-checkbox');
      checkboxes.forEach(cb => cb.checked = selectAll.checked);
      updateBatchSummary();
    };

    // Update batch summary
    window.updateBatchSummary = function() {
      const checkboxes = document.querySelectorAll('.batch-emp-checkbox:checked');
      document.getElementById('cert-batch-selected-count').textContent = checkboxes.length;

      let totalHours = 0;
      checkboxes.forEach(cb => {
        const row = cb.closest('tr');
        const hoursText = row.cells[3].textContent;
        totalHours += parseFloat(hoursText);
      });
      document.getElementById('cert-batch-total-hours').textContent = totalHours.toFixed(1);
    };

    // Update batch Valid Until
    window.updateBatchValidUntil = function() {
      const dateOfIssuance = document.getElementById('cert-batch-date-of-issuance').value;
      if (dateOfIssuance) {
        const date = new Date(dateOfIssuance);
        date.setFullYear(date.getFullYear() + 1);
        date.setDate(date.getDate() - 1); // Subtract 1 day (1 year minus 1 day)
        document.getElementById('cert-batch-valid-until').value = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
      }
    };

    // Generate batch certificates
    window.generateBatchCertificates = async function() {
      const month = parseInt(document.getElementById('cert-batch-month').value);
      const year = parseInt(document.getElementById('cert-batch-year').value);
      const dateOfIssuance = document.getElementById('cert-batch-date-of-issuance').value;
      const checkboxes = document.querySelectorAll('.batch-emp-checkbox:checked');

      if (checkboxes.length === 0) {
        Modal.error('Validation Error', 'Please select at least one employee');
        return;
      }

      if (!dateOfIssuance) {
        Modal.error('Validation Error', 'Please select Date of Issuance');
        return;
      }

      const employeeIds = Array.from(checkboxes).map(cb => cb.dataset.employeeid);

      const submitBtn = document.getElementById('generate-all-certs-btn');
      const btnText = submitBtn.querySelector('.btn-text');
      const spinner = submitBtn.querySelector('.spinner-border');

      try {
        // Show spinner
        submitBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .generateBatchCertificates_SERVER({
              employeeIds: employeeIds,
              month: month,
              year: year,
              dateOfIssuance: dateOfIssuance
            });
        });

        if (result.success) {
          // Determine if batch succeeded or failed
          const allFailed = result.successCount === 0;

          // Build success details with PDF links
          let successDetails = '';
          if (result.successCount > 0) {
            const successes = result.results.filter(r => r.success);

            successDetails = `
              <div class="mt-3">
                <h5 class="text-success mb-2">Generated Certificates:</h5>
                <div style="max-height: 400px; overflow-y: auto;">
                  <table class="table table-sm table-bordered">
                    <thead>
                      <tr>
                        <th style="width: 35%;">Employee</th>
                        <th>Certificate</th>
                        <th>Summary</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${successes.map(success => `
                        <tr>
                          <td>${success.employeeName || success.employeeId}</td>
                          <td>
                            <a href="${success.pdfUrl}" target="_blank" class="btn btn-sm btn-primary">
                              <i class="bi bi-file-pdf"></i> View
                            </a>
                          </td>
                          <td>
                            <a href="${success.summaryPdfUrl}" target="_blank" class="btn btn-sm btn-success">
                              <i class="bi bi-file-pdf"></i> View
                            </a>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              </div>
            `;
          }

          // Build error details if any failures occurred
          let errorDetails = '';
          if (result.failCount > 0) {
            const failures = result.results.filter(r => !r.success);

            // Get employee names from the table
            const employeeNames = {};
            checkboxes.forEach(cb => {
              const row = cb.closest('tr');
              const employeeId = cb.dataset.employeeid;
              const employeeName = row.cells[1].textContent;
              employeeNames[employeeId] = employeeName;
            });

            errorDetails = `
              <div class="mt-3">
                <h5 class="text-danger mb-2">Failed Certificates:</h5>
                <div style="max-height: 300px; overflow-y: auto;">
                  <table class="table table-sm table-bordered">
                    <thead>
                      <tr>
                        <th style="width: 40%;">Employee</th>
                        <th>Error</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${failures.map((failure, index) => `
                        <tr>
                          <td>${employeeNames[failure.employeeId] || failure.employeeId}</td>
                          <td class="text-danger">${failure.error}</td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              </div>
            `;
          }

          // Show different message based on success/failure
          const title = allFailed ? 'Batch Generation Failed!' : 'Batch Generation Complete!';

          const message = `
            <div class="text-center">
              <table class="table table-bordered text-start mx-auto" style="max-width: 400px;">
                <tbody>
                  <tr>
                    <td style="width: 50%;"><strong>Success</strong></td>
                    <td><strong class="text-success">${result.successCount}</strong> certificates</td>
                  </tr>
                  <tr>
                    <td><strong>Failed</strong></td>
                    <td><strong class="text-danger">${result.failCount}</strong> certificates</td>
                  </tr>
                </tbody>
              </table>
              ${successDetails}
              ${errorDetails}
            </div>
          `;

          // Use error modal if all failed, success modal if at least one succeeded
          if (allFailed) {
            Modal.error(title, message);
          } else {
            Modal.success(title, message);
          }

          // Clear selection and reload
          document.getElementById('cert-batch-month').value = '';
          document.getElementById('cert-batch-year').value = '';
          document.getElementById('cert-batch-date-of-issuance').value = '';
          document.getElementById('cert-batch-valid-until').value = '';
          document.getElementById('cert-batch-table-section').style.display = 'none';

          // Refresh By Employee tab if an employee is selected
          const selectedEmployeeId = document.getElementById('cert-employee').value;
          if (selectedEmployeeId) {
            // Check if any of the batch employees match the selected employee
            if (employeeIds.includes(selectedEmployeeId)) {
              // Reload uncertified months for this employee
              loadUncertifiedMonths();
            }
          }
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Failed to generate batch certificates: ' + error);
      } finally {
        // Hide spinner
        submitBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    };

    // Old updateSelectedTotal function removed - no longer needed with new certificate approach

    // View Certificates Functions
    (function() {
      // Populate year dropdown on page load
      const yearSelect = document.getElementById('cert-view-year');
      if (yearSelect) {
        const currentYear = new Date().getFullYear();
        for (let year = currentYear; year >= currentYear - 5; year--) {
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          yearSelect.appendChild(option);
        }
      }
    })();

    window.loadCertificates = async function() {
      const loadingDiv = document.getElementById('cert-view-loading');
      const tbody = document.getElementById('certificatesTableBody');

      const year = document.getElementById('cert-view-year').value;
      const month = document.getElementById('cert-view-month').value;
      const search = document.getElementById('cert-view-search').value;

      try {
        loadingDiv.style.display = 'block';
        tbody.innerHTML = ''; // Clear tbody, loading message is shown in loadingDiv

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getCertificates_SERVER({
              year: year,
              month: month,
              search: search
            });
        });

        loadingDiv.style.display = 'none';

        if (result.success && result.certificates.length > 0) {
          tbody.innerHTML = result.certificates.map(cert => {
            const issuanceDate = new Date(cert.dateOfIssuance);
            const validUntilDate = new Date(cert.validUntil);

            // Format dates as mm/dd/yyyy
            const formatDate = (date) => {
              const mm = String(date.getMonth() + 1).padStart(2, '0');
              const dd = String(date.getDate()).padStart(2, '0');
              const yyyy = date.getFullYear();
              return `${mm}/${dd}/${yyyy}`;
            };

            const statusBadge = cert.status === 'Active'
              ? '<span class="badge bg-success">Active</span>'
              : '<span class="badge bg-secondary">Expired</span>';

            // Certificate PDF button
            const certPdfButton = cert.pdfUrl
              ? `<a href="${cert.pdfUrl}" target="_blank" class="btn btn-sm btn-primary me-1" title="Certificate PDF">
                   <i class="bi bi-file-pdf"></i> Cert
                 </a>`
              : '';

            // Summary PDF button
            const summaryPdfButton = cert.summaryPdfUrl
              ? `<a href="${cert.summaryPdfUrl}" target="_blank" class="btn btn-sm btn-success" title="Overtime Summary PDF">
                   <i class="bi bi-file-pdf"></i> Summary
                 </a>`
              : '';

            const pdfButtons = `
              <div class="d-flex flex-wrap gap-1 align-items-center">
                ${certPdfButton}
                ${summaryPdfButton}
              </div>
            `;

            return `
              <tr>
                <td style="width: 15%;"><code class="small">${cert.certificateId}</code></td>
                <td style="width: 20%;">${cert.employeeName}</td>
                <td style="width: 15%;">${cert.period}</td>
                <td style="width: 10%;"><strong>${cert.totalHours.toFixed(1)}</strong> hrs</td>
                <td style="width: 10%;">${formatDate(issuanceDate)}</td>
                <td style="width: 10%;">${formatDate(validUntilDate)}</td>
                <td style="width: 8%;">${statusBadge}</td>
                <td style="width: 12%;">${pdfButtons}</td>
              </tr>
            `;
          }).join('');
        } else {
          tbody.innerHTML = '<tr><td colspan="8" class="text-center">No certificates found</td></tr>';
        }

      } catch (error) {
        loadingDiv.style.display = 'none';
        tbody.innerHTML = '<tr><td colspan="8" class="text-center text-danger">Error loading certificates</td></tr>';
        Modal.error('Error', 'Failed to load certificates: ' + error);
      }
    };

    window.clearCertFilters = function() {
      document.getElementById('cert-view-year').value = '';
      document.getElementById('cert-view-month').value = '';
      document.getElementById('cert-view-search').value = '';
      document.getElementById('certificatesTableBody').innerHTML = '<tr><td colspan="8" class="text-center">Select filters and load certificates</td></tr>';
    };

    window.loadEmployeeLedger = async function() {
      const employeeId = document.getElementById('ledger-employee').value;
      const tbody = document.getElementById('ledgerTableBody');
      const exportBtn = document.getElementById('export-ledger-btn');

      if (!employeeId) {
        tbody.innerHTML = '<tr><td colspan="6" class="text-center">Select an employee</td></tr>';
        exportBtn.disabled = true;
        currentLedgerData = [];
        currentEmployeeName = '';
        return;
      }

      // Show loading state
      tbody.innerHTML = '<tr><td colspan="6" class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Loading transactions...</td></tr>';
      exportBtn.disabled = true;

      // Get employee name for export
      try {
        const employeeDoc = await getDoc(doc(db, 'employees', employeeId));
        if (employeeDoc.exists()) {
          const emp = employeeDoc.data();
          currentEmployeeName = `${emp.firstName} ${emp.lastName}`;
          if (emp.suffix) {
            const needsComma = emp.suffix.toLowerCase().includes('jr') || emp.suffix.toLowerCase().includes('sr');
            currentEmployeeName += needsComma ? `, ${emp.suffix}` : ` ${emp.suffix}`;
          }
        } else {
          currentEmployeeName = employeeId;
        }
      } catch (error) {
        console.error('Error fetching employee:', error);
        currentEmployeeName = employeeId;
      }

      try {
        const batchesQ = query(
          collection(db, 'creditBatches'),
          where('employeeId', '==', employeeId),
          where('status', '==', 'Active')
        );

        onSnapshot(batchesQ, (snapshot) => {
          let balance = 0;
          snapshot.forEach(doc => {
            balance += Number(doc.data().remainingHours || 0);
          });
          document.getElementById('ledger-balance').textContent = balance.toFixed(2);
        }, (error) => {
          console.error('Error loading balance:', error);
          document.getElementById('ledger-balance').textContent = '0.00';
        });

        // Query ledger with most recent transaction first (DESC order)
        // Composite index created for: employeeId, transactionDate DESC, createdAt DESC
        const ledgerQ = query(
          collection(db, 'ledger'),
          where('employeeId', '==', employeeId),
          orderBy('transactionDate', 'desc'),
          orderBy('createdAt', 'desc')
        );

        onSnapshot(ledgerQ, async (snapshot) => {
          try {
            if (snapshot.empty) {
              tbody.innerHTML = '<tr><td colspan="6" class="text-center">No transactions</td></tr>';
              return;
            }

            // Build rows with async data fetching
            const rows = [];
            const exportData = [];
            for (const docSnap of snapshot.docs) {
              const ledger = docSnap.data();
              const date = new Date(ledger.transactionDate);

              let particularsHtml = '';
              let particularsText = '';
              let earnedHtml = '—';
              let usedHtml = '—';
              let earnedValue = '';
              let usedValue = '';
              let viewDetailsHtml = '<span class="text-muted">—</span>';

              if (ledger.transactionType === 'Earned') {
                // Fetch batch details to get month/year
                try {
                  let batchDoc;
                  // Try to get batch by referenceId (could be certificateId or batchId)
                  if (ledger.referenceId && ledger.referenceId.startsWith('BATCH_')) {
                    batchDoc = await getDoc(doc(db, 'creditBatches', ledger.referenceId));
                  } else if (ledger.referenceId) {
                    // Search for batch with this certificateId
                    const batchQ = query(
                      collection(db, 'creditBatches'),
                      where('certificateId', '==', ledger.referenceId),
                      where('employeeId', '==', employeeId)
                    );
                    const batchSnap = await getDocs(batchQ);
                    if (!batchSnap.empty) {
                      batchDoc = batchSnap.docs[0];
                    }
                  }

                  if (batchDoc && batchDoc.exists()) {
                    const batch = batchDoc.data();
                    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                       'July', 'August', 'September', 'October', 'November', 'December'];

                    if (batch.source === 'Historical') {
                      const month = monthNames[batch.earnedMonth - 1] || 'Unknown';
                      const year = batch.earnedYear || 'Unknown';
                      particularsHtml = `<strong>Historical Balance</strong><br><small class="text-muted">${month} ${year}</small>`;
                      particularsText = `Historical Balance - ${month} ${year}`;
                      viewDetailsHtml = `<button class="btn btn-sm btn-outline-info" onclick="viewHistoricalBalanceDetails('${batchDoc.id}')"><i class="bi bi-eye"></i> View</button>`;
                    } else {
                      const month = monthNames[batch.earnedMonth - 1] || 'Unknown';
                      const year = batch.earnedYear || 'Unknown';
                      particularsHtml = `<strong>COC Earned</strong><br><small class="text-muted">${month} ${year}</small>`;
                      particularsText = `COC Earned - ${month} ${year}`;
                      viewDetailsHtml = `<button class="btn btn-sm btn-outline-success" onclick="viewCocEarnedDetails('${batchDoc.id}')"><i class="bi bi-eye"></i> View</button>`;
                    }
                  } else {
                    particularsHtml = `<strong>COC Earned</strong><br><small class="text-muted">${ledger.referenceId || 'N/A'}</small>`;
                    particularsText = `COC Earned - ${ledger.referenceId || 'N/A'}`;
                    // Try to find batch by referenceId for view button
                    if (ledger.referenceId) {
                      viewDetailsHtml = `<button class="btn btn-sm btn-outline-success" onclick="viewCocEarnedDetailsByRef('${ledger.referenceId}', '${employeeId}')"><i class="bi bi-eye"></i> View</button>`;
                    }
                  }
                } catch (error) {
                  console.error('Error fetching batch details:', error);
                  particularsHtml = `<strong>COC Earned</strong><br><small class="text-muted">${ledger.referenceId || 'N/A'}</small>`;
                  particularsText = `COC Earned - ${ledger.referenceId || 'N/A'}`;
                  // Try to add view button even on error
                  if (ledger.referenceId) {
                    viewDetailsHtml = `<button class="btn btn-sm btn-outline-success" onclick="viewCocEarnedDetailsByRef('${ledger.referenceId}', '${employeeId}')"><i class="bi bi-eye"></i> View</button>`;
                  }
                }
                earnedHtml = `<span class="text-success"><strong>${ledger.hoursChange.toFixed(2)}</strong></span>`;
                earnedValue = ledger.hoursChange.toFixed(2);
              } else if (ledger.transactionType === 'Used') {
                // CTO application
                const dateRange = ledger.inclusiveDateFrom && ledger.inclusiveDateTo
                  ? `${new Date(ledger.inclusiveDateFrom).toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'Asia/Manila' })} - ${new Date(ledger.inclusiveDateTo).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'Asia/Manila' })}`
                  : '';

                // Check if CTO is cancelled
                const isCancelled = ledger.status === 'Cancelled';
                const statusBadge = isCancelled
                  ? '<span class="badge bg-danger ms-1">CANCELLED</span>'
                  : '';
                const cancelledText = isCancelled ? ' (CANCELLED)' : '';

                particularsHtml = `<strong>CTO Application${statusBadge}</strong><br><small class="text-muted">${dateRange}</small>`;
                particularsText = `CTO Application${cancelledText} - ${dateRange}`;
                usedHtml = `<span class="text-danger"><strong>${Math.abs(ledger.hoursChange).toFixed(2)}</strong></span>`;
                usedValue = Math.abs(ledger.hoursChange).toFixed(2);
                viewDetailsHtml = `<button class="btn btn-sm btn-outline-primary" onclick="viewCtoDetails('${ledger.ledgerId}')"><i class="bi bi-eye"></i> View</button>`;
              } else {
                particularsHtml = ledger.remarks || ledger.referenceId || 'N/A';
                particularsText = ledger.remarks || ledger.referenceId || 'N/A';
                if (ledger.hoursChange >= 0) {
                  earnedHtml = `<span class="text-success"><strong>${ledger.hoursChange.toFixed(2)}</strong></span>`;
                  earnedValue = ledger.hoursChange.toFixed(2);
                } else {
                  usedHtml = `<span class="text-danger"><strong>${Math.abs(ledger.hoursChange).toFixed(2)}</strong></span>`;
                  usedValue = Math.abs(ledger.hoursChange).toFixed(2);
                }
              }

              // Store data for export
              exportData.push({
                date: date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }),
                particulars: particularsText,
                earned: earnedValue,
                used: usedValue,
                balance: ledger.balanceAfter.toFixed(2)
              });

              rows.push(`
                <tr>
                  <td>${date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td>
                  <td>${particularsHtml}</td>
                  <td class="text-end">${earnedHtml}</td>
                  <td class="text-end">${usedHtml}</td>
                  <td class="text-end"><strong>${ledger.balanceAfter.toFixed(2)}</strong></td>
                  <td class="text-center">${viewDetailsHtml}</td>
                </tr>
              `);
            }

            // Store data for export and enable button
            currentLedgerData = exportData;
            exportBtn.disabled = false;

            tbody.innerHTML = rows.join('');
          } catch (error) {
            console.error('Error rendering ledger:', error);
            tbody.innerHTML = '<tr><td colspan="6" class="text-center text-danger">Error loading transactions. Please try again.</td></tr>';
          }
        }, (error) => {
          console.error('Error loading ledger:', error);
          tbody.innerHTML = '<tr><td colspan="6" class="text-center text-danger">Error: ' + error.message + '</td></tr>';
        });
      } catch (error) {
        console.error('Error in loadEmployeeLedger:', error);
        tbody.innerHTML = '<tr><td colspan="6" class="text-center text-danger">Error loading data. Please try again.</td></tr>';
      }
    };

    // Export ledger to Excel (CSV format)
    let currentLedgerData = [];
    let currentEmployeeName = '';

    window.exportLedgerToExcel = function() {
      const employeeId = document.getElementById('ledger-employee').value;
      if (!employeeId || currentLedgerData.length === 0) {
        Modal.error('No Data', 'Please select an employee and ensure ledger data is loaded.');
        return;
      }

      // Prepare CSV data
      const headers = ['Date', 'Particulars', 'Earned (hrs)', 'Used (hrs)', 'Balance (hrs)'];
      const csvRows = [];

      // Add header
      csvRows.push(headers.join(','));

      // Add data rows
      currentLedgerData.forEach(row => {
        const csvRow = [
          `"${row.date}"`,
          `"${row.particulars.replace(/"/g, '""')}"`, // Escape quotes
          row.earned || '',
          row.used || '',
          row.balance
        ];
        csvRows.push(csvRow.join(','));
      });

      // Create CSV blob
      const csvContent = csvRows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

      // Create download link
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);

      // Generate filename with employee name and date
      const today = new Date().toISOString().split('T')[0];
      const filename = `Employee_Ledger_${currentEmployeeName.replace(/[^a-z0-9]/gi, '_')}_${today}.csv`;
      link.setAttribute('download', filename);

      // Trigger download
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };

    // Store the current balance listener so we can unsubscribe
    let ctoBalanceUnsubscribe = null;

    window.showCtoBalance = async function() {
      const employeeId = document.getElementById('cto-employee').value;
      if (!employeeId) {
        document.getElementById('cto-available-balance').textContent = '0.00';
        // Unsubscribe from previous listener if exists
        if (ctoBalanceUnsubscribe) {
          ctoBalanceUnsubscribe();
          ctoBalanceUnsubscribe = null;
        }
        return;
      }

      try {
        // Unsubscribe from previous listener if exists
        if (ctoBalanceUnsubscribe) {
          ctoBalanceUnsubscribe();
        }

        const batchesQ = query(
          collection(db, 'creditBatches'),
          where('employeeId', '==', employeeId),
          where('status', '==', 'Active')
        );

        ctoBalanceUnsubscribe = onSnapshot(batchesQ,
          (snapshot) => {
            let total = 0;
            snapshot.forEach(doc => {
              const data = doc.data();
              total += Number(data.remainingHours || 0);
            });
            document.getElementById('cto-available-balance').textContent = total.toFixed(2);
          },
          (error) => {
            console.error('Error fetching CTO balance:', error);
            document.getElementById('cto-available-balance').textContent = '0.00';
          }
        );
      } catch (error) {
        console.error('Error setting up CTO balance listener:', error);
        document.getElementById('cto-available-balance').textContent = '0.00';
      }
    };

    window.calculateHistoricalRemaining = function() {
      const earned = parseFloat(document.getElementById('hist-coc-earned').value) || 0;
      const used = parseFloat(document.getElementById('hist-coc-used').value) || 0;
      const dateIssuance = document.getElementById('hist-date-issuance').value;

      const remaining = earned - used;
      document.getElementById('hist-remaining').value = remaining >= 0 ? remaining.toFixed(2) + ' hours' : 'Invalid';

      let validUntil = null;
      if (dateIssuance) {
        const issuanceDate = new Date(dateIssuance);
        validUntil = new Date(issuanceDate);
        validUntil.setFullYear(validUntil.getFullYear() + 1);
        validUntil.setDate(validUntil.getDate() - 1);

        const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'Asia/Manila' };
        document.getElementById('hist-valid-until').value = validUntil.toLocaleDateString('en-US', options);
      } else {
        document.getElementById('hist-valid-until').value = '';
      }

      // Calculate status with expiry check
      let status;
      if (remaining < 0) {
        status = 'Invalid';
      } else if (remaining === 0) {
        status = 'Used';
      } else {
        // Has remaining hours - check if expired
        if (validUntil) {
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const expiry = new Date(validUntil);
          expiry.setHours(0, 0, 0, 0);

          // "Valid Until Nov 11" means valid through entire day of Nov 11
          // Should only expire on Nov 12 onwards
          if (today > expiry) {
            status = 'Expired';
          } else {
            status = 'Active';
          }
        } else {
          status = 'Active';
        }
      }

      document.getElementById('hist-status').value = status;
    };

    document.getElementById('hist-date-issuance').addEventListener('change', calculateHistoricalRemaining);

    // Historical Balances List Management
    let historicalBalancesData = [];

    function loadHistoricalBalances() {
      if (!selectedHistoricalEmployee) {
        const tbody = document.getElementById('historicalBalancesTableBody');
        tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">Select an employee above to view their historical balances</td></tr>`;
        return;
      }

      console.log('Loading historical balances for employee:', selectedHistoricalEmployee);

      // Simpler query - only filter by employeeId, then filter source client-side
      const q = query(
        collection(db, 'creditBatches'),
        where('employeeId', '==', selectedHistoricalEmployee)
      );

      const unsubscribe = onSnapshot(q,
        async (snapshot) => {
          console.log('Snapshot received, docs count:', snapshot.docs.length);
          historicalBalancesData = [];

          for (const docSnapshot of snapshot.docs) {
            const batch = docSnapshot.data();
            console.log('Batch data:', batch);

            // Filter by source on client-side to avoid composite index requirement
            if (batch.source === 'Historical') {
              historicalBalancesData.push({
                id: docSnapshot.id,
                ...batch
              });
            }
          }

          console.log('Filtered historical balances:', historicalBalancesData.length);

          // Sort by monthYear descending (client-side)
          historicalBalancesData.sort((a, b) => {
            if (a.monthYear && b.monthYear) {
              return b.monthYear.localeCompare(a.monthYear);
            }
            return 0;
          });

          renderHistoricalBalancesTable();
        },
        (error) => {
          console.error('Error loading historical balances:', error);
          const tbody = document.getElementById('historicalBalancesTableBody');
          tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">Error loading data: ${error.message}</td></tr>`;
        }
      );

      unsubscribers.push(unsubscribe);
    }

    function renderHistoricalBalancesTable() {
      const tbody = document.getElementById('historicalBalancesTableBody');

      if (historicalBalancesData.length === 0) {
        tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">No historical balances found for this employee</td></tr>`;
        return;
      }

      tbody.innerHTML = historicalBalancesData.map(batch => {
        // Convert Firestore Timestamps to JavaScript Dates
        const convertDate = (dateField) => {
          if (!dateField) return '-';
          // Handle Firestore Timestamp
          if (dateField.toDate) return dateField.toDate();
          // Handle string dates
          if (typeof dateField === 'string') return new Date(dateField);
          // Already a Date object
          if (dateField instanceof Date) return dateField;
          return new Date(dateField);
        };

        const issuanceDate = convertDate(batch.dateOfIssuance);
        const expiryDate = convertDate(batch.expiryDate);

        const issuedDate = issuanceDate !== '-' ? issuanceDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '-';
        const validUntilDate = expiryDate !== '-' ? expiryDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '-';

        // Format month/year
        const monthYear = batch.monthYear || '-';

        // Dynamic status calculation (checked at runtime)
        let actualStatus = batch.status;
        let statusBadge = '';

        const today = new Date();
        today.setHours(0, 0, 0, 0); // Reset to start of day for comparison

        // Determine status based on remaining hours and expiry date
        if (batch.remainingHours === 0 || batch.remainingHours === undefined) {
          actualStatus = 'Used';
        } else if (batch.remainingHours > 0) {
          // Has remaining hours - check if expired
          if (expiryDate !== '-') {
            const expiry = new Date(expiryDate);
            expiry.setHours(0, 0, 0, 0);

            // If current date is AFTER expiry date (not on the expiry date itself), mark as expired
            // "Valid Until Nov 11" means valid through the entire day of Nov 11
            // Should only expire on Nov 12 onwards
            if (today > expiry) {
              actualStatus = 'Expired';
            } else {
              actualStatus = 'Active';
            }
          } else {
            // No expiry date but has remaining hours - mark as Active
            actualStatus = 'Active';
          }
        }

        // Status badge based on actual (dynamic) status
        if (actualStatus === 'Active') {
          statusBadge = '<span class="badge bg-success">Active</span>';
        } else if (actualStatus === 'Used') {
          statusBadge = '<span class="badge bg-secondary">Used</span>';
        } else if (actualStatus === 'Expired') {
          statusBadge = '<span class="badge bg-danger">Expired</span>';
        }

        return `
          <tr>
            <td>${monthYear}</td>
            <td>${batch.initialHours ? batch.initialHours.toFixed(1) : '0.0'}</td>
            <td>${batch.usedHours ? batch.usedHours.toFixed(1) : '0.0'}</td>
            <td><strong>${batch.remainingHours ? batch.remainingHours.toFixed(1) : '0.0'}</strong></td>
            <td>${issuedDate}</td>
            <td>${validUntilDate}</td>
            <td>${statusBadge}</td>
            <td>
              <button class="btn btn-sm btn-outline-primary me-1" onclick="editHistoricalBalance('${batch.id}')" title="Edit" id="hist-edit-${batch.id}">
                <i class="bi bi-pencil"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger" onclick="deleteHistoricalBalance('${batch.id}')" title="Delete" id="hist-delete-${batch.id}">
                <i class="bi bi-trash"></i>
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    window.deleteHistoricalBalance = async function(batchId) {
      Modal.confirm(
        'Delete Historical Balance',
        'Are you sure you want to delete this historical balance entry? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteHistoricalBalance_SERVER(batchId);
            });

            if (result.success) {
              Modal.success('Success!', 'Historical balance deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting historical balance: ' + error);
          }
        }
      );
    };

    window.editHistoricalBalance = function(batchId) {
      const batch = historicalBalancesData.find(b => b.id === batchId);
      if (!batch) {
        Modal.error('Error', 'Historical balance not found');
        return;
      }

      // Populate form with batch data
      document.getElementById('hist-batch-id').value = batchId;
      document.getElementById('hist-is-edit').value = 'true';
      document.getElementById('hist-month-year').value = batch.monthYear;
      document.getElementById('hist-coc-earned').value = batch.initialHours || batch.earnedHours;
      document.getElementById('hist-coc-used').value = batch.usedHours || 0;

      // Enable and set Date of Issuance
      enableDateOfIssuance();
      const issuanceDate = batch.dateOfIssuance || batch.issueDate;
      if (issuanceDate) {
        const date = new Date(issuanceDate);
        const formatDate = (d) => {
          const year = d.getFullYear();
          const month = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        document.getElementById('hist-date-issuance').value = formatDate(date);
      }

      validateHistoricalFields();

      // Update button text and show Cancel button
      document.getElementById('hist-submit-text').textContent = 'Update';
      document.getElementById('hist-cancel-btn').classList.remove('d-none');

      // Switch to Add tab
      document.getElementById('tab-add-hist').click();

      // Scroll to form
      document.getElementById('content-add-hist').scrollIntoView({ behavior: 'smooth' });
    };

    window.cancelEditHistoricalBalance = function() {
      resetHistoricalForm();
      // Switch to list tab
      document.getElementById('tab-list-hist').click();
    };

    window.resetHistoricalForm = function() {
      const form = document.getElementById('historicalForm');
      const employeeName = document.getElementById('hist-employee-name').value;
      const employeeId = document.getElementById('hist-employee').value;

      form.reset();
      form.classList.remove('was-validated');

      // Clear hidden fields
      document.getElementById('hist-batch-id').value = '';
      document.getElementById('hist-is-edit').value = 'false';

      // Restore employee info
      document.getElementById('hist-employee-name').value = employeeName;
      document.getElementById('hist-employee').value = employeeId;

      // Reset date field
      document.getElementById('hist-date-issuance').disabled = true;
      document.getElementById('hist-date-issuance').value = '';

      // Reset validation
      document.getElementById('hist-coc-earned').classList.remove('is-invalid');
      document.getElementById('hist-coc-used').classList.remove('is-invalid');

      // Reset calculated fields
      calculateHistoricalRemaining();

      // Reset button text and hide Cancel button
      document.getElementById('hist-submit-text').textContent = 'Migrate';
      document.getElementById('hist-cancel-btn').classList.add('d-none');
    };

    // ========== LOG OVERTIME FEATURE ==========

    // Global state for overtime entries
    let overtimeEntries = [];
    let overtimeRowCounter = 0;
    let overtimeMonthlyTotal = 0;
    let overtimeTotalBalance = 0;

    // Initialize year dropdown (current year and previous 2 years)
    (function initializeOvertimeYearDropdown() {
      const yearSelect = document.getElementById('ot-year');
      const currentYear = new Date().getFullYear();
      for (let i = 0; i < 3; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (i === 0) option.selected = true;
        yearSelect.appendChild(option);
      }
    })();

    // Filter overtime employees
    window.filterOvertimeEmployees = function() {
      const searchInput = document.getElementById('ot-employee-search');
      const dropdown = document.getElementById('ot-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-item-custom text-muted">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showOvertimeEmployeeDropdown();
    };

    window.showOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectOvertimeEmployee = function(employeeId, name) {
      const searchInput = document.getElementById('ot-employee-search');
      const hiddenInput = document.getElementById('ot-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideOvertimeEmployeeDropdown();
      updateOvertimeMonthOptions(); // Update month options based on employee/year
    };

    // Store original month names
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    const historicalBalanceCache = new Map();

    function resetMonthOption(option) {
      if (option.value === '') return;
      const monthValue = parseInt(option.value);
      option.disabled = false;
      option.textContent = monthNames[monthValue];
      option.classList.remove('text-muted');
      delete option.dataset.state;
    }

    function applyFutureStates(monthSelect, selectedYear) {
      const today = new Date();
      const currentYear = today.getFullYear();
      const currentMonth = today.getMonth();

      Array.from(monthSelect.options).forEach(option => {
        if (option.value === '') return;
        const monthValue = parseInt(option.value);
        const monthName = monthNames[monthValue];
        const isFuture = (selectedYear > currentYear) || (selectedYear === currentYear && monthValue > currentMonth);

        if (isFuture) {
          option.disabled = true;
          option.textContent = `${monthName} (Future)`;
          option.classList.add('text-muted');
          option.dataset.state = 'future';
        } else {
          option.dataset.state = 'available';
        }
      });
    }

    function applyHistoricalStates(monthSelect, historicalMonths) {
      const historicalSet = new Set(historicalMonths);
      Array.from(monthSelect.options).forEach(option => {
        if (option.value === '' || option.dataset.state === 'future') return;
        const monthValue = parseInt(option.value);
        if (historicalSet.has(monthValue)) {
          const monthName = monthNames[monthValue];
          option.disabled = true;
          option.textContent = `${monthName} (Historical Balance)`;
          option.classList.add('text-muted');
          option.dataset.state = 'historical';
        }
      });
    }

    function applyOvertimeIndicators(monthSelect, overtimeMonths) {
      const overtimeSet = new Set(overtimeMonths);
      Array.from(monthSelect.options).forEach(option => {
        if (option.value === '' || option.dataset.state === 'future' || option.dataset.state === 'historical') return;
        const monthValue = parseInt(option.value);
        const monthName = monthNames[monthValue];

        if (overtimeSet.has(monthValue)) {
          // Add green dot indicator for months with entries
          option.textContent = `🟢 ${monthName}`;
          option.style.color = '#059669'; // Green color
          option.style.fontWeight = '500';
          option.dataset.hasEntries = 'true';
        }
      });
    }

    function ensureValidMonthSelection(monthSelect) {
      if (!monthSelect) return;
      const selectedValue = monthSelect.value;
      if (selectedValue === '') return;
      const selectedOption = monthSelect.options[monthSelect.selectedIndex];
      if (!selectedOption || selectedOption.disabled) {
        monthSelect.value = '';
      }
    }

    // Update month options to disable future months and months with historical balance
    window.updateOvertimeMonthOptions = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const yearInput = document.getElementById('ot-year').value;
      const monthSelect = document.getElementById('ot-month');

      if (!monthSelect) {
        return;
      }

      Array.from(monthSelect.options).forEach(resetMonthOption);

      if (!employeeId || !yearInput) {
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
        return;
      }

      const year = parseInt(yearInput);
      applyFutureStates(monthSelect, year);
      ensureValidMonthSelection(monthSelect);

      const cacheKey = `${employeeId}-${year}`;
      const cachedMonths = historicalBalanceCache.get(cacheKey);
      if (cachedMonths) {
        applyHistoricalStates(monthSelect, cachedMonths);
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
        return;
      }

      try {
        // Load historical balance and overtime months in PARALLEL
        const [histResult, overtimeResult] = await Promise.all([
          new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getHistoricalBalanceMonths_SERVER(employeeId, year);
          }),
          new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getOvertimeMonths_SERVER(employeeId, year);
          })
        ]);

        // Apply historical states
        const historicalMonths = Array.isArray(histResult.months) ? histResult.months : [];
        historicalBalanceCache.set(cacheKey, historicalMonths);
        applyHistoricalStates(monthSelect, historicalMonths);

        // Apply overtime indicators
        const overtimeMonths = Array.isArray(overtimeResult.months) ? overtimeResult.months : [];
        applyOvertimeIndicators(monthSelect, overtimeMonths);

      } catch (error) {
        console.error('Error updating month options:', error);
      } finally {
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
      }
    };

    // Update overtime context (when employee/month/year changes)
    window.updateOvertimeContext = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const month = document.getElementById('ot-month').value;
      const year = document.getElementById('ot-year').value;

      const alertContainer = document.getElementById('ot-alert-container');
      const loadingContainer = document.getElementById('ot-entry-loading');
      const tableWrapper = document.getElementById('ot-entry-table-wrapper');
      const entrySection = document.getElementById('ot-entry-section');
      const totalSection = document.getElementById('ot-total-section');
      const submitSection = document.getElementById('ot-submit-section');

      const hideEntryContent = () => {
        if (loadingContainer) loadingContainer.classList.remove('active');
        if (tableWrapper) tableWrapper.classList.add('d-none');
      };

      const toggleEntryLoading = (isLoading) => {
        if (!loadingContainer || !tableWrapper) return;
        const addDayBtn = document.getElementById('ot-add-day-btn');
        if (isLoading) {
          loadingContainer.classList.add('active');
          tableWrapper.classList.add('d-none');
          if (addDayBtn) addDayBtn.disabled = true;
        } else {
          loadingContainer.classList.remove('active');
          tableWrapper.classList.remove('d-none');
          if (addDayBtn) addDayBtn.disabled = false;
        }
      };

      alertContainer.innerHTML = '';

      // Reset state variables at the start
      overtimeMonthlyTotal = 0;
      overtimeTotalBalance = 0;
      overtimeEntries = [];
      overtimeRowCounter = 0;

      if (!employeeId || month === '' || !year) {
        // Hide all sections if incomplete
        document.getElementById('ot-progress-section').style.display = 'none';
        if (entrySection) entrySection.style.display = 'none';
        if (totalSection) totalSection.style.display = 'none';
        if (submitSection) submitSection.style.display = 'none';
        hideEntryContent();

        // Reset display to zero
        document.getElementById('ot-monthly-hours').textContent = '0.0';
        document.getElementById('ot-total-hours').textContent = '0.0';
        document.getElementById('ot-monthly-progress').style.width = '0%';
        document.getElementById('ot-total-progress').style.width = '0%';

        // Hide spinners
        const monthlySpinner = document.getElementById('ot-monthly-spinner');
        const totalSpinner = document.getElementById('ot-total-spinner');
        if (monthlySpinner) monthlySpinner.classList.add('d-none');
        if (totalSpinner) totalSpinner.classList.add('d-none');

        return;
      }

      // Show progress section and loading state
      document.getElementById('ot-progress-section').style.display = 'flex';
      if (entrySection) entrySection.style.display = 'block';
      if (totalSection) totalSection.style.display = 'none';
      if (submitSection) submitSection.style.display = 'none';
      toggleEntryLoading(true);

      // Show spinners while loading
      const monthlySpinner = document.getElementById('ot-monthly-spinner');
      const totalSpinner = document.getElementById('ot-total-spinner');
      if (monthlySpinner) monthlySpinner.classList.remove('d-none');
      if (totalSpinner) totalSpinner.classList.remove('d-none');

      try {
        // Check for certificate or historical balance blocking
        const blockCheck = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .checkOvertimeBlocks_SERVER(employeeId, parseInt(month), parseInt(year));
        });

        if (!blockCheck.success) {
          alertContainer.innerHTML = `
            <div class="alert alert-danger">
              <i class="bi bi-exclamation-triangle-fill"></i>
              <strong>Blocked:</strong> ${blockCheck.error}
            </div>
          `;
          if (entrySection) entrySection.style.display = 'none';
          if (totalSection) totalSection.style.display = 'none';
          if (submitSection) submitSection.style.display = 'none';
          hideEntryContent();
          // Hide spinners
          if (monthlySpinner) monthlySpinner.classList.add('d-none');
          if (totalSpinner) totalSpinner.classList.add('d-none');
          return;
        }

        // Load data in PARALLEL for faster performance
        const [existingLogs, balanceData] = await Promise.all([
          new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getUncertifiedOvertimeForMonth_SERVER(employeeId, parseInt(month), parseInt(year));
          }),
          new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .getTotalBalance_SERVER(employeeId);
          })
        ]);

        // Calculate monthly total
        overtimeMonthlyTotal = existingLogs.reduce((sum, log) => sum + Number(log.earnedHours || 0), 0);

        // Process balance data
        if (!balanceData.success) {
          throw new Error(balanceData.error || 'Unable to retrieve total balance');
        }

        const activeBalance = Number(balanceData.active || 0);
        const uncertifiedBalance = Number(balanceData.uncertified || 0);
        overtimeTotalBalance = activeBalance + uncertifiedBalance;

        // Update progress bars
        updateOvertimeProgress();

        // Hide spinners after data is loaded
        if (monthlySpinner) monthlySpinner.classList.add('d-none');
        if (totalSpinner) totalSpinner.classList.add('d-none');

        // Clear existing entries first
        overtimeEntries = [];
        overtimeRowCounter = 0;
        document.getElementById('ot-entries-tbody').innerHTML = '';

        // Load existing uncertified logs into the form
        if (existingLogs && existingLogs.length > 0) {
          for (const log of existingLogs) {
            // Parse the overtimeDate to get the day
            const logDate = new Date(log.overtimeDate);
            const day = logDate.getDate();

            // Add row for this entry
            const rowId = ++overtimeRowCounter;
            const tbody = document.getElementById('ot-entries-tbody');
            const row = document.createElement('tr');
            row.id = `ot-row-${rowId}`;
            row.innerHTML = `
              <td>
                <input type="number" class="form-control form-control-sm" id="ot-date-${rowId}" min="1" max="31"
                       placeholder="Day" inputmode="numeric" oninput="onOvertimeDateChange(${rowId})" required>
              </td>
              <td>
                <span class="badge bg-secondary" id="ot-daytype-${rowId}">-</span>
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" id="ot-am-in-${rowId}"
                       oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" id="ot-am-out-${rowId}"
                       oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" id="ot-pm-in-${rowId}"
                       oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" id="ot-pm-out-${rowId}"
                       oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
              </td>
              <td>
                <input type="text" class="form-control form-control-sm" id="ot-hours-worked-${rowId}"
                       readonly style="background-color: #f8f9fa;">
              </td>
              <td>
                <input type="text" class="form-control form-control-sm" id="ot-coc-earned-${rowId}"
                       readonly style="background-color: #f8f9fa;">
              </td>
              <td>
                <button type="button" class="btn btn-sm btn-danger" onclick="removeOvertimeDay(${rowId})" title="Remove">
                  <i class="bi bi-trash"></i>
                </button>
              </td>
            `;
            tbody.appendChild(row);

            // Create entry object
            const entry = {
              rowId: rowId,
              date: null,
              dayType: log.dayType || 'weekday',
              isHoliday: log.isHoliday || false,
              holidayName: log.holidayName || '',
              amIn: log.amIn || '',
              amOut: log.amOut || '',
              pmIn: log.pmIn || '',
              pmOut: log.pmOut || '',
              hoursWorked: Number(log.hoursWorked || 0),
              cocEarned: Number(log.earnedHours || 0),
              error: null
            };
            overtimeEntries.push(entry);

            // Populate the form fields
            document.getElementById(`ot-date-${rowId}`).value = day;
            if (log.amIn) document.getElementById(`ot-am-in-${rowId}`).value = log.amIn;
            if (log.amOut) document.getElementById(`ot-am-out-${rowId}`).value = log.amOut;
            if (log.pmIn) document.getElementById(`ot-pm-in-${rowId}`).value = log.pmIn;
            if (log.pmOut) document.getElementById(`ot-pm-out-${rowId}`).value = log.pmOut;
            document.getElementById(`ot-hours-worked-${rowId}`).value = entry.hoursWorked.toFixed(1);
            document.getElementById(`ot-coc-earned-${rowId}`).value = entry.cocEarned.toFixed(1);

            // Set day type badge
            const badge = document.getElementById(`ot-daytype-${rowId}`);
            if (log.isHoliday) {
              badge.textContent = log.holidayName || 'Holiday';
              badge.className = 'badge bg-danger';
            } else if (log.dayType === 'weekend') {
              badge.textContent = 'Weekend';
              badge.className = 'badge bg-warning text-dark';
            } else {
              badge.textContent = 'Weekday';
              badge.className = 'badge bg-primary';
            }

            // Trigger date change to set the date properly
            entry.date = logDate.toISOString().split('T')[0];
          }
        }

        // Show entry section
        toggleEntryLoading(false);
        if (entrySection) entrySection.style.display = 'block';
        if (totalSection) totalSection.style.display = 'block';
        if (submitSection) submitSection.style.display = 'block';

        // Calculate grand total
        calculateOvertimeGrandTotal();

      } catch (error) {
        console.error('Error updating overtime context:', error);
        Modal.error('Error', 'Failed to load overtime context: ' + error);
        hideEntryContent();
        if (entrySection) entrySection.style.display = 'none';
        if (totalSection) totalSection.style.display = 'none';
        if (submitSection) submitSection.style.display = 'none';
        // Hide spinners on error
        const monthlySpinner = document.getElementById('ot-monthly-spinner');
        const totalSpinner = document.getElementById('ot-total-spinner');
        if (monthlySpinner) monthlySpinner.classList.add('d-none');
        if (totalSpinner) totalSpinner.classList.add('d-none');
      }
    };

    // Update progress bars
    function updateOvertimeProgress() {
      // Monthly accrual - only count what's in the form
      // (existing uncertified logs are already loaded into the form)
      const entriesTotal = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);
      const monthlyTotal = entriesTotal;
      const monthlyPercent = Math.min((monthlyTotal / 40) * 100, 100);

      document.getElementById('ot-monthly-hours').textContent = monthlyTotal.toFixed(1);
      const monthlyBar = document.getElementById('ot-monthly-progress');
      monthlyBar.style.width = monthlyPercent + '%';
      monthlyBar.className = monthlyPercent >= 100 ? 'progress-bar bg-danger' :
                             monthlyPercent >= 80 ? 'progress-bar bg-warning' :
                             'progress-bar bg-success';

      // Total balance - Active + Uncertified(other months) + current entries
      // overtimeTotalBalance already includes ALL uncertified (including current month)
      // So we subtract current month's uncertified, then add what's in the form
      const currentOvertimeBalance = (typeof overtimeTotalBalance !== 'undefined') ? overtimeTotalBalance : 0;
      const currentMonthUncertified = (typeof overtimeMonthlyTotal !== 'undefined') ? overtimeMonthlyTotal : 0;
      const totalBalance = currentOvertimeBalance - currentMonthUncertified + entriesTotal;
      const totalPercent = Math.min((totalBalance / 120) * 100, 100);

      document.getElementById('ot-total-hours').textContent = totalBalance.toFixed(1);
      const totalBar = document.getElementById('ot-total-progress');
      totalBar.style.width = totalPercent + '%';
      totalBar.className = totalPercent >= 100 ? 'progress-bar bg-danger' :
                           totalPercent >= 80 ? 'progress-bar bg-warning' :
                           'progress-bar bg-success';
    }

    // Add overtime day row
    window.addOvertimeDay = function() {
      const rowId = ++overtimeRowCounter;
      const tbody = document.getElementById('ot-entries-tbody');

      const row = document.createElement('tr');
      row.id = `ot-row-${rowId}`;
      row.innerHTML = `
        <td>
          <input type="number" class="form-control form-control-sm" id="ot-date-${rowId}" min="1" max="31"
                 placeholder="Day" inputmode="numeric" oninput="onOvertimeDateChange(${rowId})" required>
        </td>
        <td>
          <span class="badge bg-secondary" id="ot-daytype-${rowId}">-</span>
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-am-in-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-am-out-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-pm-in-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-pm-out-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="text" class="form-control form-control-sm" id="ot-hours-worked-${rowId}"
                 readonly style="background-color: #f8f9fa;">
        </td>
        <td>
          <input type="text" class="form-control form-control-sm" id="ot-coc-earned-${rowId}"
                 readonly style="background-color: #f8f9fa;">
        </td>
        <td>
          <button type="button" class="btn btn-sm btn-danger" onclick="removeOvertimeDay(${rowId})" title="Remove">
            <i class="bi bi-trash"></i>
          </button>
        </td>
      `;

      tbody.appendChild(row);

      // Add to entries array
      overtimeEntries.push({
        rowId: rowId,
        date: null,
        displayDate: null,
        dayType: null,
        amIn: null,
        amOut: null,
        pmIn: null,
        pmOut: null,
        hoursWorked: 0,
        cocEarned: 0
      });
    };

    // Remove overtime day row
    window.removeOvertimeDay = function(rowId) {
      const row = document.getElementById(`ot-row-${rowId}`);
      if (row) row.remove();

      // Remove from entries array
      overtimeEntries = overtimeEntries.filter(entry => entry.rowId !== rowId);

      calculateOvertimeGrandTotal();
      updateOvertimeProgress();
    };

    function formatISODateForDisplay(isoDate) {
      if (!isoDate) return '';
      const parts = isoDate.split('-').map(Number);
      if (parts.length !== 3) return isoDate;
      const [year, month, day] = parts;
      const date = new Date(year, month - 1, day);
      if (Number.isNaN(date.getTime())) return isoDate;
      return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    }

    function resetOvertimeEntryDate(entry, rowId) {
      if (!entry) return;

      entry.date = null;
      entry.displayDate = null;
      entry.dayType = null;
      entry.isHoliday = false;
      entry.holidayName = '';
      entry.hoursWorked = 0;
      entry.cocEarned = 0;
      entry.error = null;

      const badge = document.getElementById(`ot-daytype-${rowId}`);
      if (badge) {
        badge.textContent = '-';
        badge.className = 'badge bg-secondary';
      }

      const hoursField = document.getElementById(`ot-hours-worked-${rowId}`);
      if (hoursField) hoursField.value = '';
      const cocField = document.getElementById(`ot-coc-earned-${rowId}`);
      if (cocField) cocField.value = '';
    }

    function formatOvertimeEntryLabel(entry) {
      if (!entry) return 'selected day';
      if (entry.displayDate) return entry.displayDate;
      if (entry.date) return formatISODateForDisplay(entry.date);
      return 'selected day';
    }

    // Debounce timers for date validation (to prevent false duplicates while typing)
    const dateValidationTimers = new Map();

    // On date change - auto-detect day type
    window.onOvertimeDateChange = async function(rowId) {
      const dateInput = document.getElementById(`ot-date-${rowId}`);
      const entry = overtimeEntries.find(e => e.rowId === rowId);
      if (!dateInput || !entry) return;

      const rawValue = dateInput.value;

      if (!rawValue) {
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      // Clear existing timer for this row
      if (dateValidationTimers.has(rowId)) {
        clearTimeout(dateValidationTimers.get(rowId));
      }

      // Debounce validation to allow user to finish typing (e.g., "11" instead of just "1")
      const timer = setTimeout(async () => {
        await validateAndProcessOvertimeDate(rowId, dateInput, entry, rawValue);
        dateValidationTimers.delete(rowId);
      }, 400); // Wait 400ms after user stops typing

      dateValidationTimers.set(rowId, timer);
    };

    // Separated validation logic for debouncing
    async function validateAndProcessOvertimeDate(rowId, dateInput, entry, rawValue) {

      if (!rawValue) {
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const day = parseInt(rawValue, 10);
      if (Number.isNaN(day)) {
        Modal.error('Invalid Day', 'Please enter a valid day number (1-31).');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const monthValue = document.getElementById('ot-month').value;
      const yearValue = document.getElementById('ot-year').value;

      if (monthValue === '' || !yearValue) {
        Modal.error('Incomplete Selection', 'Please select the overtime month and year first.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const selectedMonth = parseInt(monthValue, 10);
      const selectedYear = parseInt(yearValue, 10);

      if (Number.isNaN(selectedMonth) || Number.isNaN(selectedYear)) {
        Modal.error('Invalid Selection', 'Selected month or year is invalid.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const candidateDate = new Date(selectedYear, selectedMonth, day);
      if (candidateDate.getMonth() !== selectedMonth || candidateDate.getFullYear() !== selectedYear || candidateDate.getDate() !== day) {
        Modal.error('Invalid Day', 'The entered day is not valid for the selected month.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const isoDate = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const comparisonDate = new Date(candidateDate);
      comparisonDate.setHours(0, 0, 0, 0);
      if (comparisonDate > today) {
        Modal.error('Invalid Date', 'Future dates are not allowed.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const duplicateCount = overtimeEntries.filter(item => item.rowId !== rowId && item.date === isoDate).length;
      if (duplicateCount > 0) {
        Modal.error('Duplicate Date', 'This day has already been entered for the selected month.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      entry.date = isoDate;
      entry.displayDate = formatISODateForDisplay(isoDate);

      let resolvedDayType = 'weekday';
      let isHoliday = false;
      let holidayName = '';

      const badge = document.getElementById(`ot-daytype-${rowId}`);

      try {
        const dayTypeResult = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getDayType_SERVER(isoDate);
        });

        if (badge) {
          if (dayTypeResult.isHoliday) {
            badge.textContent = `Holiday (${dayTypeResult.holidayName})`;
            badge.className = 'badge bg-danger';
          } else if (dayTypeResult.isWeekend) {
            badge.textContent = 'Weekend';
            badge.className = 'badge bg-warning text-dark';
          } else {
            badge.textContent = 'Weekday';
            badge.className = 'badge bg-primary';
          }
        }

        if (dayTypeResult.isHoliday) {
          resolvedDayType = 'holiday';
          isHoliday = true;
          holidayName = dayTypeResult.holidayName || '';
        } else if (dayTypeResult.isWeekend) {
          resolvedDayType = 'weekend';
        }
      } catch (error) {
        console.error('Error detecting day type:', error);
        if (badge) {
          badge.textContent = 'Weekday';
          badge.className = 'badge bg-primary';
        }
      }

      entry.dayType = resolvedDayType;
      entry.isHoliday = isHoliday;
      entry.holidayName = holidayName;

      calculateOvertimeRow(rowId);
    }

    // Calculate overtime for a single row
    window.calculateOvertimeRow = function(rowId) {
      const entry = overtimeEntries.find(e => e.rowId === rowId);
      if (!entry || !entry.date) return;

      const amInEl = document.getElementById(`ot-am-in-${rowId}`);
      const amOutEl = document.getElementById(`ot-am-out-${rowId}`);
      const pmInEl = document.getElementById(`ot-pm-in-${rowId}`);
      const pmOutEl = document.getElementById(`ot-pm-out-${rowId}`);

      const amIn = amInEl.value;
      const amOut = amOutEl.value;
      const pmIn = pmInEl.value;
      const pmOut = pmOutEl.value;

      // Clear all validation states first
      [amInEl, amOutEl, pmInEl, pmOutEl].forEach(el => {
        el.classList.remove('is-invalid');
        el.classList.remove('border-danger');
      });

      // Update entry
      entry.amIn = amIn;
      entry.amOut = amOut;
      entry.pmIn = pmIn;
      entry.pmOut = pmOut;

      // Validate time inputs
      let isValid = true;
      let errorMsg = '';
      const invalidFields = [];

      // AM validation
      if (amIn && amOut) {
        const amInTime = parseTime(amIn);
        const amOutTime = parseTime(amOut);

        // AM In: Must be 5:00 AM - 12:59 PM
        if (amInTime < parseTime('05:00') || amInTime >= parseTime('13:00')) {
          errorMsg = 'AM In must be between 5:00 AM and 12:59 PM';
          isValid = false;
          invalidFields.push(amInEl);
        }

        // AM Out: Must be 8:00 AM - 12:59 PM
        if (amOutTime < parseTime('08:00') || amOutTime >= parseTime('13:00')) {
          errorMsg = errorMsg || 'AM Out must be between 8:00 AM and 12:59 PM';
          isValid = false;
          invalidFields.push(amOutEl);
        }

        // AM Out must be after AM In
        if (isValid && amOutTime <= amInTime) {
          errorMsg = 'AM Out must be after AM In';
          isValid = false;
          invalidFields.push(amInEl, amOutEl);
        }
      } else if (amIn || amOut) {
        errorMsg = 'Both AM In and AM Out must be filled';
        isValid = false;
        if (amIn && !amOut) invalidFields.push(amOutEl);
        if (!amIn && amOut) invalidFields.push(amInEl);
      }

      // PM validation
      if (pmIn && pmOut) {
        const pmInTime = parseTime(pmIn);
        const pmOutTime = parseTime(pmOut);

        // PM In: Must be 12:00 PM - 11:59 PM
        if (pmInTime < parseTime('12:00')) {
          errorMsg = errorMsg || 'PM In must be 12:00 PM or later';
          isValid = false;
          invalidFields.push(pmInEl);
        }

        // PM Out: Must be 12:00 PM - 11:59 PM
        if (pmOutTime < parseTime('12:00')) {
          errorMsg = errorMsg || 'PM Out must be 12:00 PM or later';
          isValid = false;
          invalidFields.push(pmOutEl);
        }

        // PM Out must be after PM In
        if (isValid && pmOutTime <= pmInTime) {
          errorMsg = errorMsg || 'PM Out must be after PM In';
          isValid = false;
          invalidFields.push(pmInEl, pmOutEl);
        }
      } else if (pmIn || pmOut) {
        errorMsg = errorMsg || 'Both PM In and PM Out must be filled';
        isValid = false;
        if (pmIn && !pmOut) invalidFields.push(pmOutEl);
        if (!pmIn && pmOut) invalidFields.push(pmInEl);
      }

      // Noon break validation
      if (amOut && pmIn && isValid) {
        if (parseTime(pmIn) <= parseTime(amOut)) {
          errorMsg = 'PM In must be after AM Out (noon break required)';
          isValid = false;
          invalidFields.push(amOutEl, pmInEl);
        }
      }

      // Apply visual feedback to invalid fields
      invalidFields.forEach(el => {
        el.classList.add('is-invalid');
        el.classList.add('border-danger');
      });

      if (!isValid) {
        entry.hoursWorked = 0;
        entry.cocEarned = 0;
        entry.error = errorMsg;

        // Show error tooltip or console message
        if (invalidFields.length > 0) {
          invalidFields[0].title = errorMsg;
        }
      } else {
        entry.error = null;

        // Calculate hours worked and COC earned
        const result = calculateOvertimeHours(entry.dayType || 'weekday', amIn, amOut, pmIn, pmOut);
        entry.hoursWorked = result.hoursWorked;
        entry.cocEarned = result.cocEarned;
      }

      // Update display
      document.getElementById(`ot-hours-worked-${rowId}`).value = entry.hoursWorked.toFixed(1);
      document.getElementById(`ot-coc-earned-${rowId}`).value = entry.cocEarned.toFixed(1);

      calculateOvertimeGrandTotal();
      updateOvertimeProgress();
    };

    // Helper: Parse time string to minutes
    function parseTime(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    }

    // Helper: Calculate overlap between two time ranges (in minutes)
    function calculateOverlap(start1, end1, start2, end2) {
      const overlapStart = Math.max(start1, start2);
      const overlapEnd = Math.min(end1, end2);
      return Math.max(0, overlapEnd - overlapStart);
    }

    // Calculate overtime hours with TIME WINDOWS
    function calculateOvertimeHours(dayType, amIn, amOut, pmIn, pmOut) {
      let hoursWorked = 0;
      let cocEarned = 0;

      if (dayType === 'weekday') {
        // WEEKDAY: Only PM window 5:00 PM - 7:00 PM counts
        // Rate: 1.0x
        if (pmIn && pmOut) {
          const pmInTime = parseTime(pmIn);
          const pmOutTime = parseTime(pmOut);
          const windowStart = parseTime('17:00'); // 5:00 PM
          const windowEnd = parseTime('19:00');   // 7:00 PM

          // Calculate overlap with window
          const overlapMinutes = calculateOverlap(pmInTime, pmOutTime, windowStart, windowEnd);
          const hours = overlapMinutes / 60;

          hoursWorked += hours;
          cocEarned += hours * 1.0; // 1.0x rate
        }
      } else {
        // WEEKEND/HOLIDAY: Two windows with 1.5x rate

        // AM Window: 8:00 AM - 12:00 PM
        if (amIn && amOut) {
          const amInTime = parseTime(amIn);
          const amOutTime = parseTime(amOut);
          const windowStart = parseTime('08:00'); // 8:00 AM
          const windowEnd = parseTime('12:00');   // 12:00 PM

          // Calculate overlap with AM window
          const overlapMinutes = calculateOverlap(amInTime, amOutTime, windowStart, windowEnd);
          const hours = overlapMinutes / 60;

          hoursWorked += hours;
          cocEarned += hours * 1.5; // 1.5x rate
        }

        // PM Window: 1:00 PM - 5:00 PM
        if (pmIn && pmOut) {
          const pmInTime = parseTime(pmIn);
          const pmOutTime = parseTime(pmOut);
          const windowStart = parseTime('13:00'); // 1:00 PM
          const windowEnd = parseTime('17:00');   // 5:00 PM

          // Calculate overlap with PM window
          const overlapMinutes = calculateOverlap(pmInTime, pmOutTime, windowStart, windowEnd);
          const hours = overlapMinutes / 60;

          hoursWorked += hours;
          cocEarned += hours * 1.5; // 1.5x rate
        }
      }

      return {
        hoursWorked: hoursWorked,
        cocEarned: cocEarned
      };
    }

    // Calculate grand total
    function calculateOvertimeGrandTotal() {
      const totalHoursWorked = overtimeEntries.reduce((sum, entry) => sum + Number(entry.hoursWorked || 0), 0);
      const totalCocEarned = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);

      document.getElementById('ot-grand-hours-worked').textContent = totalHoursWorked.toFixed(1);
      document.getElementById('ot-grand-coc-earned').textContent = totalCocEarned.toFixed(1);
    }

    // Submit overtime form
    window.submitOvertimeForm = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const month = parseInt(document.getElementById('ot-month').value);
      const year = parseInt(document.getElementById('ot-year').value);

      // Validation
      if (!employeeId || month === '' || !year) {
        Modal.error('Validation Error', 'Please select employee, month, and year.');
        return;
      }

      if (overtimeEntries.length === 0) {
        Modal.error('Validation Error', 'Please add at least one overtime entry.');
        return;
      }

      // Validate all entries have required data
      for (const entry of overtimeEntries) {
        if (!entry.date) {
          Modal.error('Validation Error', 'All entries must have a date.');
          return;
        }

        const entryLabel = formatOvertimeEntryLabel(entry);

        if (!entry.amIn && !entry.amOut && !entry.pmIn && !entry.pmOut) {
          Modal.error('Validation Error', `Entry for ${entryLabel} has no time inputs.`);
          return;
        }
        if (entry.error) {
          Modal.error('Validation Error', `Entry for ${entryLabel}: ${entry.error}`);
          return;
        }
      }

      // Check monthly cap
      const totalCocEarned = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);
      const newMonthlyTotal = overtimeMonthlyTotal + totalCocEarned;

      if (newMonthlyTotal > 40) {
        Modal.error('Monthly Cap Exceeded',
          `Total would be ${newMonthlyTotal.toFixed(1)} hours, exceeding the 40-hour monthly accrual cap.`);
        return;
      }

      // Check total balance cap
      const currentOvertimeBalance = (typeof overtimeTotalBalance !== 'undefined') ? overtimeTotalBalance : 0;
      const newTotalBalance = currentOvertimeBalance + totalCocEarned;
      if (newTotalBalance > 120) {
        Modal.error('Total Balance Cap Exceeded',
          `Total balance would be ${newTotalBalance.toFixed(1)} hours, exceeding the 120-hour cap.`);
        return;
      }

      // Get elements to disable
      const submitBtn = document.querySelector('button[onclick="submitOvertimeForm()"]');
      const addDayBtn = document.getElementById('ot-add-day-btn');
      const spinner = document.getElementById('ot-submit-spinner');
      const employeeInput = document.getElementById('ot-employee-search');
      const monthSelect = document.getElementById('ot-month');
      const yearSelect = document.getElementById('ot-year');
      const allInputs = document.querySelectorAll('#ot-entries-tbody input, #ot-entries-tbody button');

      // Disable all elements
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.style.opacity = '0.6';
        submitBtn.style.cursor = 'not-allowed';
      }
      if (addDayBtn) addDayBtn.disabled = true;
      if (employeeInput) employeeInput.disabled = true;
      if (monthSelect) monthSelect.disabled = true;
      if (yearSelect) yearSelect.disabled = true;
      allInputs.forEach(input => input.disabled = true);

      // Show spinner
      spinner.classList.remove('d-none');

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .logOvertimeBatch_SERVER({
              employeeId: employeeId,
              month: month,
              year: year,
              entries: overtimeEntries.map(entry => ({
                date: entry.date,
                dayType: entry.dayType,
                isHoliday: entry.isHoliday,
                holidayName: entry.holidayName,
                amIn: entry.amIn,
                amOut: entry.amOut,
                pmIn: entry.pmIn,
                pmOut: entry.pmOut,
                hoursWorked: entry.hoursWorked,
                cocEarned: entry.cocEarned
              }))
            });
        });

        if (result.success) {
          // Build summary message
          const summaryParts = [];
          if (result.created > 0) summaryParts.push(`${result.created} created`);
          if (result.updated > 0) summaryParts.push(`${result.updated} updated`);
          if (result.deleted > 0) summaryParts.push(`${result.deleted} deleted`);
          const summary = summaryParts.join(', ');

          const message = `
            <div class="text-center">
              <table class="table table-bordered mt-3 text-start mx-auto" style="max-width: 500px;">
                <tbody>
                  <tr>
                    <td style="width: 40%;"><strong>Summary</strong></td>
                    <td>${summary}</td>
                  </tr>
                  <tr>
                    <td><strong>Total COC Earned</strong></td>
                    <td><strong class="text-primary">${result.totalCocEarned.toFixed(1)}</strong> hours (Uncertified)</td>
                  </tr>
                  <tr>
                    <td colspan="2" class="text-center text-muted">
                      <small>Generate a certificate to activate these credits.</small>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          `;
          Modal.success('Overtime Saved Successfully!', message);

          // Reset form - keep employee, clear month/year
          document.getElementById('ot-month').value = '';
          document.getElementById('ot-year').value = '';
          overtimeEntries = [];
          document.getElementById('ot-entries-tbody').innerHTML = '';
          calculateOvertimeGrandTotal();
          updateOvertimeContext(); // This will hide sections since month/year are empty
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Failed to log overtime: ' + error);
      } finally {
        // Re-enable all elements
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.style.opacity = '1';
          submitBtn.style.cursor = 'pointer';
        }
        if (addDayBtn) addDayBtn.disabled = false;
        if (employeeInput) employeeInput.disabled = false;
        if (monthSelect) monthSelect.disabled = false;
        if (yearSelect) yearSelect.disabled = false;
        allInputs.forEach(input => input.disabled = false);
        spinner.classList.add('d-none');
      }
    };

    // Click outside to close dropdown
    document.addEventListener('click', function(e) {
      const otContainer = document.querySelector('#ot-employee-search')?.closest('.searchable-select-container');
      if (otContainer && !otContainer.contains(e.target)) {
        hideOvertimeEmployeeDropdown();
      }
    });

    // CTO Day Breakdown Functions
    // Validate filing date is not in the future
    window.validateFilingDate = function() {
      const filingDateInput = document.getElementById('cto-filing-date');
      const errorDiv = document.getElementById('cto-filing-date-error');
      const filingDate = new Date(filingDateInput.value);
      filingDate.setHours(0, 0, 0, 0);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (filingDate > today) {
        filingDateInput.classList.add('is-invalid');
        errorDiv.style.display = 'block';
        return false;
      } else {
        filingDateInput.classList.remove('is-invalid');
        errorDiv.style.display = 'none';
        return true;
      }
    };

    // Enable inclusive date fields when filing date is selected
    window.enableInclusiveDates = function() {
      const filingDate = document.getElementById('cto-filing-date').value;
      const dateFromField = document.getElementById('cto-date-from');
      const dateToField = document.getElementById('cto-date-to');

      if (filingDate) {
        dateFromField.disabled = false;
        dateToField.disabled = false;
        // Set min date for inclusive dates to be >= filing date
        dateFromField.min = filingDate;
        dateToField.min = filingDate;
      } else {
        dateFromField.disabled = true;
        dateToField.disabled = true;
        dateFromField.value = '';
        dateToField.value = '';
        document.getElementById('cto-day-breakdown-section').style.display = 'none';
      }
    };

    window.generateDayBreakdown = function() {
      const filingDate = document.getElementById('cto-filing-date').value;
      const dateFrom = document.getElementById('cto-date-from').value;
      const dateTo = document.getElementById('cto-date-to').value;
      const dateFromField = document.getElementById('cto-date-from');
      const dateFromError = document.getElementById('cto-date-from-error');
      const dateToField = document.getElementById('cto-date-to');
      const dateToError = document.getElementById('cto-date-to-error');

      // Clear previous error states
      dateFromField.classList.remove('is-invalid');
      dateFromError.style.display = 'none';
      dateToField.classList.remove('is-invalid');
      dateToError.style.display = 'none';

      if (!dateFrom || !dateTo) {
        document.getElementById('cto-day-breakdown-section').style.display = 'none';
        return;
      }

      const filing = new Date(filingDate);
      const start = new Date(dateFrom);
      const end = new Date(dateTo);

      // Validation: Date of Filing should not be later than Inclusive Date From
      if (filing > start) {
        dateFromField.classList.add('is-invalid');
        dateFromError.style.display = 'block';
        document.getElementById('cto-day-breakdown-section').style.display = 'none';
        return;
      }

      // Validation: Inclusive Date To should not be earlier than Inclusive Date From
      if (end < start) {
        dateToField.classList.add('is-invalid');
        dateToError.style.display = 'block';
        document.getElementById('cto-day-breakdown-section').style.display = 'none';
        return;
      }

      // Check max 5 consecutive days
      const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
      if (daysDiff > 5) {
        Modal.error('Invalid Range', 'CTO can only be availed continuously up to a maximum of 5 consecutive days per single availment.');
        document.getElementById('cto-day-breakdown-section').style.display = 'none';
        return;
      }

      // All validations passed - ensure errors are cleared
      dateFromField.classList.remove('is-invalid');
      dateFromError.style.display = 'none';
      dateToField.classList.remove('is-invalid');
      dateToError.style.display = 'none';

      const content = document.getElementById('cto-day-breakdown-content');
      const days = [];
      const current = new Date(start);

      let html = '<div class="row">';
      while (current <= end) {
        const dateStr = current.toISOString().split('T')[0];
        const dateDisplay = current.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });

        html += `
          <div class="col-md-12 mb-2">
            <div class="p-2 border rounded bg-white">
              <div class="row align-items-center">
                <div class="col-md-4">
                  <strong>${dateDisplay}</strong>
                </div>
                <div class="col-md-8">
                  <div class="btn-group" role="group">
                    <input type="radio" class="btn-check" name="day-${dateStr}" id="whole-${dateStr}" value="8" onchange="calculateCtototalHours()" checked>
                    <label class="btn btn-outline-primary" for="whole-${dateStr}">
                      <i class="bi bi-calendar-day"></i> Whole Day (8 hrs)
                    </label>
                    <input type="radio" class="btn-check" name="day-${dateStr}" id="half-${dateStr}" value="4" onchange="calculateCtototalHours()">
                    <label class="btn btn-outline-primary" for="half-${dateStr}">
                      <i class="bi bi-calendar2-minus"></i> Half Day (4 hrs)
                    </label>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;

        current.setDate(current.getDate() + 1);
      }
      html += '</div>';

      content.innerHTML = html;
      document.getElementById('cto-day-breakdown-section').style.display = 'block';
      calculateCtototalHours();
    };

    window.calculateCtototalHours = function() {
      const dateFrom = document.getElementById('cto-date-from').value;
      const dateTo = document.getElementById('cto-date-to').value;

      if (!dateFrom || !dateTo) return;

      const start = new Date(dateFrom);
      const end = new Date(dateTo);
      const current = new Date(start);

      let totalHours = 0;
      while (current <= end) {
        const dateStr = current.toISOString().split('T')[0];
        const selected = document.querySelector(`input[name="day-${dateStr}"]:checked`);
        if (selected) {
          totalHours += parseInt(selected.value);
        }
        current.setDate(current.getDate() + 1);
      }

      document.getElementById('cto-total-hours-display').textContent = totalHours;
      document.getElementById('cto-hours').value = totalHours;

      // Check if we're editing and hours are being reduced
      checkRestoreRemarksVisibility();
    };

    // Check if restore remarks section should be shown
    window.checkRestoreRemarksVisibility = function() {
      const isEditing = document.getElementById('cto-ledger-id').value !== '';
      const originalHours = parseFloat(document.getElementById('cto-original-hours').value) || 0;
      const newHours = parseFloat(document.getElementById('cto-hours').value) || 0;
      const restoreSection = document.getElementById('cto-restore-remarks-section');

      // Check if elements exist before accessing them
      if (!restoreSection) {
        return;
      }

      if (isEditing && originalHours > 0 && newHours < originalHours) {
        // Hours are being reduced - show restore remarks
        restoreSection.style.display = 'block';
      } else {
        // Not reducing hours - hide restore remarks
        restoreSection.style.display = 'none';
        // Clear the field and error if they exist
        const remarksField = document.getElementById('cto-restore-remarks');
        const remarksError = document.getElementById('cto-restore-remarks-error');
        if (remarksField) {
          remarksField.value = '';
        }
        if (remarksError) {
          remarksError.style.display = 'none';
        }
      }
    };

    window.getDayBreakdown = function() {
      const dateFrom = document.getElementById('cto-date-from').value;
      const dateTo = document.getElementById('cto-date-to').value;

      if (!dateFrom || !dateTo) return {};

      const start = new Date(dateFrom);
      const end = new Date(dateTo);
      const current = new Date(start);
      const breakdown = {};

      while (current <= end) {
        const dateStr = current.toISOString().split('T')[0];
        const selected = document.querySelector(`input[name="day-${dateStr}"]:checked`);
        if (selected) {
          breakdown[dateStr] = parseInt(selected.value);
        }
        current.setDate(current.getDate() + 1);
      }

      return breakdown;
    };

    window.editCtoApplication = function(ledgerId, buttonElement) {
      // Show loading state
      const loadingSpinner = document.createElement('div');
      loadingSpinner.className = 'spinner-border spinner-border-sm';
      loadingSpinner.setAttribute('role', 'status');
      loadingSpinner.innerHTML = '<span class="visually-hidden">Loading...</span>';

      // Disable all edit buttons
      const editButtons = document.querySelectorAll('button[onclick*="editCtoApplication"]');
      editButtons.forEach(btn => {
        btn.disabled = true;
        btn.classList.add('opacity-50');
      });

      // If buttonElement is provided, show spinner in it
      if (buttonElement && buttonElement instanceof HTMLElement) {
        const originalContent = buttonElement.innerHTML;
        buttonElement.innerHTML = '';
        buttonElement.appendChild(loadingSpinner);
        buttonElement.dataset.originalContent = originalContent;
      }

      // Load CTO data and populate form
      google.script.run
        .withSuccessHandler((result) => {
          if (result.success) {
            try {
              const cto = result.application;

              // IMMEDIATELY switch to the Log tab and scroll - before any other operations
              const logTab = document.getElementById('cto-log-tab');
              if (logTab) {
                logTab.click();
              }

              // Instant scroll to top (not smooth)
              window.scrollTo({ top: 0, behavior: 'auto' });

              // Now re-enable buttons (user sees form is loading)
              editButtons.forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('opacity-50');
                if (btn.dataset.originalContent) {
                  btn.innerHTML = btn.dataset.originalContent;
                  delete btn.dataset.originalContent;
                }
              });

              document.getElementById('cto-ledger-id').value = ledgerId;

              // Ensure employee is in dropdown (for inactive employees or not yet loaded)
              const employeeSelect = document.getElementById('cto-employee');
              let optionExists = false;
              for (let i = 0; i < employeeSelect.options.length; i++) {
                if (employeeSelect.options[i].value === cto.employeeId) {
                  optionExists = true;
                  break;
                }
              }

              // Add employee to dropdown if not present
              if (!optionExists && cto.employeeId) {
                const option = document.createElement('option');
                option.value = cto.employeeId;
                option.textContent = `${cto.employeeName} (${cto.employeeId})`;
                employeeSelect.appendChild(option);
              }

              // Now set the value
              document.getElementById('cto-employee').value = cto.employeeId;
              document.getElementById('cto-filing-date').value = cto.filingDate.split('T')[0];

              // Enable inclusive date fields
              document.getElementById('cto-date-from').disabled = false;
              document.getElementById('cto-date-to').disabled = false;

              document.getElementById('cto-date-from').value = cto.inclusiveDateFrom.split('T')[0];
              document.getElementById('cto-date-to').value = cto.inclusiveDateTo.split('T')[0];

              // Trigger day breakdown generation
              generateDayBreakdown();

              // Store original hours FIRST for restore remarks check
              const originalHours = Math.abs(cto.hoursChange || 0);
              document.getElementById('cto-original-hours').value = originalHours;

              // Change button text and show cancel button
              document.getElementById('cto-submit-text').textContent = 'Update CTO';
              document.getElementById('cto-cancel-btn').style.display = 'inline-block';

              // Set day selections if dayBreakdown exists - use requestAnimationFrame for better performance
              if (cto.dayBreakdown) {
                requestAnimationFrame(() => {
                  Object.keys(cto.dayBreakdown).forEach(date => {
                    const hours = cto.dayBreakdown[date];
                    const radio = document.getElementById(hours === 8 ? `whole-${date}` : `half-${date}`);
                    if (radio) radio.checked = true;
                  });
                  calculateCtototalHours();
                });
              }

              // Show balance asynchronously (don't block form display)
              requestAnimationFrame(() => {
                showCtoBalance();
              });

            } catch (error) {
              console.error('Error populating CTO form:', error);
              // Re-enable buttons on error
              editButtons.forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('opacity-50');
                if (btn.dataset.originalContent) {
                  btn.innerHTML = btn.dataset.originalContent;
                  delete btn.dataset.originalContent;
                }
              });
              Modal.error('Error', 'Failed to populate form: ' + error.message);
            }
          } else {
            // Re-enable buttons on error
            editButtons.forEach(btn => {
              btn.disabled = false;
              btn.classList.remove('opacity-50');
              if (btn.dataset.originalContent) {
                btn.innerHTML = btn.dataset.originalContent;
                delete btn.dataset.originalContent;
              }
            });
            Modal.error('Error', result.error);
          }
        })
        .withFailureHandler((error) => {
          // Re-enable all edit buttons and restore content
          editButtons.forEach(btn => {
            btn.disabled = false;
            btn.classList.remove('opacity-50');
            if (btn.dataset.originalContent) {
              btn.innerHTML = btn.dataset.originalContent;
              delete btn.dataset.originalContent;
            }
          });
          Modal.error('Error', 'Failed to load CTO: ' + error);
        })
        .getCtoApplication_SERVER(ledgerId);
    };

    window.cancelCtoEdit = function() {
      document.getElementById('ctoForm').reset();
      document.getElementById('cto-ledger-id').value = '';
      document.getElementById('cto-original-hours').value = '0';
      document.getElementById('cto-submit-text').textContent = 'Log CTO';
      document.getElementById('cto-cancel-btn').style.display = 'none';
      document.getElementById('cto-day-breakdown-section').style.display = 'none';
      document.getElementById('cto-restore-remarks-section').style.display = 'none';
      document.getElementById('cto-restore-remarks').value = '';
      // Element may not exist (removed when remarks made optional)
      const remarksError = document.getElementById('cto-restore-remarks-error');
      if (remarksError) {
        remarksError.style.display = 'none';
      }
      document.getElementById('cto-available-balance').textContent = '0.00';
      // Disable inclusive date fields
      document.getElementById('cto-date-from').disabled = true;
      document.getElementById('cto-date-to').disabled = true;
    };

    window.viewCtoDetails = async function(ledgerId) {
      try {
        // Fetch CTO details from Firestore
        const ledgerDoc = await getDoc(doc(db, 'ledger', ledgerId));

        if (!ledgerDoc.exists()) {
          Modal.error('Error', 'CTO application not found');
          return;
        }

        const ledger = ledgerDoc.data();

        // Fetch employee details
        const employeeDoc = await getDoc(doc(db, 'employees', ledger.employeeId));
        let employeeName = ledger.employeeId;
        if (employeeDoc.exists()) {
          const emp = employeeDoc.data();
          employeeName = `${emp.firstName} ${emp.lastName}`;
          if (emp.suffix) {
            const needsComma = emp.suffix.toLowerCase().includes('jr') || emp.suffix.toLowerCase().includes('sr');
            employeeName += needsComma ? `, ${emp.suffix}` : ` ${emp.suffix}`;
          }
        }

        // Build day breakdown HTML as table
        let dayBreakdownHtml = '';
        if (ledger.dayBreakdown && Object.keys(ledger.dayBreakdown).length > 0) {
          dayBreakdownHtml = '<table class="table table-sm table-bordered mb-0"><tbody>';
          Object.keys(ledger.dayBreakdown).sort().forEach(date => {
            const hours = ledger.dayBreakdown[date];
            const dateObj = new Date(date);
            const formattedDate = dateObj.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', timeZone: 'Asia/Manila' });
            dayBreakdownHtml += `<tr><td>${formattedDate}</td><td class="text-end"><strong>${hours} hrs</strong></td></tr>`;
          });
          dayBreakdownHtml += '</tbody></table>';
        } else {
          dayBreakdownHtml = '<span class="text-muted">N/A</span>';
        }

        // Build FIFO deduction info as table
        let fifoHtml = '';
        if (ledger.deductedFrom && ledger.deductedFrom.length > 0) {
          fifoHtml = '<table class="table table-sm table-bordered mb-0"><tbody>';
          ledger.deductedFrom.forEach(deduction => {
            fifoHtml += `<tr><td>${deduction.month} ${deduction.year}</td><td class="text-end"><strong>${deduction.hours} hrs</strong></td></tr>`;
          });
          fifoHtml += '</tbody></table>';
        } else {
          fifoHtml = '<span class="text-muted">N/A</span>';
        }

        const filingDate = ledger.filingDate ? new Date(ledger.filingDate).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A';
        const dateFrom = ledger.inclusiveDateFrom ? new Date(ledger.inclusiveDateFrom).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A';
        const dateTo = ledger.inclusiveDateTo ? new Date(ledger.inclusiveDateTo).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A';
        const hoursUsed = Math.abs(ledger.hoursChange);

        Modal.custom({
          title: 'CTO Application Details',
          icon: 'bi-file-text',
          iconColor: 'text-primary',
          message: `
            <div class="text-start">
              <table class="table table-bordered table-sm">
                <tbody>
                  <tr>
                    <th style="width: 35%;">Employee</th>
                    <td>${employeeName}</td>
                  </tr>
                  <tr>
                    <th>Employee ID</th>
                    <td>${ledger.employeeId}</td>
                  </tr>
                  <tr>
                    <th>Filing Date</th>
                    <td>${filingDate}</td>
                  </tr>
                  <tr>
                    <th>Inclusive Dates</th>
                    <td>${dateFrom} - ${dateTo}</td>
                  </tr>
                  <tr>
                    <th>Total Hours</th>
                    <td><strong>${hoursUsed.toFixed(2)} hours</strong></td>
                  </tr>
                  <tr>
                    <th>Day Breakdown</th>
                    <td>${dayBreakdownHtml}</td>
                  </tr>
                  <tr>
                    <th>Deducted From (FIFO)</th>
                    <td>${fifoHtml}</td>
                  </tr>
                  ${ledger.remarks ? `<tr><th>Remarks</th><td>${ledger.remarks}</td></tr>` : ''}
                  <tr>
                    <th>Status</th>
                    <td><span class="badge ${ledger.status === 'Active' ? 'bg-success' : 'bg-danger'}">${ledger.status || 'Active'}</span></td>
                  </tr>
                  ${ledger.status === 'Cancelled' ? `
                    <tr>
                      <th>Cancellation Reason</th>
                      <td class="text-danger"><strong>${ledger.cancellationReason || 'N/A'}</strong></td>
                    </tr>
                    <tr>
                      <th>Cancelled By</th>
                      <td>${ledger.cancelledBy || 'N/A'}</td>
                    </tr>
                    <tr>
                      <th>Cancelled At</th>
                      <td>${ledger.cancelledAt ? new Date(ledger.cancelledAt).toLocaleString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A'}</td>
                    </tr>
                  ` : ''}
                </tbody>
              </table>
            </div>
          `,
          buttons: [
            {
              text: 'Close',
              class: 'btn-secondary',
              dismiss: true
            }
          ]
        });

      } catch (error) {
        console.error('Error viewing CTO details:', error);
        Modal.error('Error', 'Failed to load CTO details: ' + error.message);
      }
    };

    // View COC Earned Details by Batch ID
    window.viewCocEarnedDetails = async function(batchId) {
      try {
        const batchDoc = await getDoc(doc(db, 'creditBatches', batchId));

        if (!batchDoc.exists()) {
          Modal.error('Error', 'COC certificate not found');
          return;
        }

        const batch = batchDoc.data();

        // Fetch employee details
        const employeeDoc = await getDoc(doc(db, 'employees', batch.employeeId));
        let employeeName = batch.employeeId;
        if (employeeDoc.exists()) {
          const emp = employeeDoc.data();
          employeeName = `${emp.firstName} ${emp.lastName}`;
          if (emp.suffix) {
            const needsComma = emp.suffix.toLowerCase().includes('jr') || emp.suffix.toLowerCase().includes('sr');
            employeeName += needsComma ? `, ${emp.suffix}` : ` ${emp.suffix}`;
          }
        }

        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
        const month = monthNames[batch.earnedMonth - 1] || 'Unknown';
        const year = batch.earnedYear || 'Unknown';

        // Fetch overtime entries for this certificate
        let overtimeEntriesHtml = '';
        let totalHours = 0;

        if (batch.certificateId) {
          try {
            const logsQ = query(
              collection(db, 'overtimeLogs'),
              where('certificateId', '==', batch.certificateId),
              where('employeeId', '==', batch.employeeId),
              orderBy('date', 'asc')
            );
            const logsSnapshot = await getDocs(logsQ);

            if (!logsSnapshot.empty) {
              overtimeEntriesHtml = `
                <h6 class="mt-3 mb-2"><strong>${month} ${year} - Overtime Entries</strong></h6>
                <p class="mb-2 small"><strong>Certificate ID:</strong> <code>${batch.certificateId}</code></p>
                <div class="table-responsive">
                  <table class="table table-bordered table-sm table-striped mb-2">
                    <thead class="table-light">
                      <tr>
                        <th>Date</th>
                        <th>Day Type</th>
                        <th>AM In</th>
                        <th>AM Out</th>
                        <th>PM In</th>
                        <th>PM Out</th>
                        <th>Hours</th>
                        <th>COC Earned</th>
                      </tr>
                    </thead>
                    <tbody>
              `;

              logsSnapshot.forEach(logDoc => {
                const log = logDoc.data();
                const logDate = log.date ? new Date(log.date).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A';
                const hoursWorked = log.hoursWorked || 0;
                const cocEarned = log.earnedHours || log.cocEarned || 0;
                totalHours += cocEarned;

                overtimeEntriesHtml += `
                  <tr>
                    <td>${logDate}</td>
                    <td>${log.dayType || 'N/A'}</td>
                    <td>${log.amTimeIn || '-'}</td>
                    <td>${log.amTimeOut || '-'}</td>
                    <td>${log.pmTimeIn || '-'}</td>
                    <td>${log.pmTimeOut || '-'}</td>
                    <td>${hoursWorked.toFixed(1)}</td>
                    <td><strong>${cocEarned.toFixed(1)}</strong></td>
                  </tr>
                `;
              });

              overtimeEntriesHtml += `
                    </tbody>
                  </table>
                </div>
                <p class="mb-0"><strong>Total: ${totalHours.toFixed(1)} hours</strong></p>
              `;
            }
          } catch (error) {
            console.error('Error fetching overtime entries:', error);
            overtimeEntriesHtml = '<p class="text-muted">Unable to load overtime entries.</p>';
          }
        }

        Modal.custom({
          title: 'COC Certificate Details',
          icon: 'bi-award',
          iconColor: 'text-success',
          message: `
            <div class="text-start">
              ${overtimeEntriesHtml}
            </div>
          `,
          buttons: [
            {
              text: 'Close',
              class: 'btn-secondary',
              dismiss: true
            }
          ]
        });

      } catch (error) {
        console.error('Error viewing COC details:', error);
        Modal.error('Error', 'Failed to load COC details: ' + error.message);
      }
    };

    // View COC Earned Details by Reference ID (certificate ID or batch ID)
    window.viewCocEarnedDetailsByRef = async function(referenceId, employeeId) {
      try {
        let batchDoc;

        // Try direct batch ID lookup first
        if (referenceId.startsWith('BATCH_')) {
          batchDoc = await getDoc(doc(db, 'creditBatches', referenceId));
        }

        // If not found, try searching by certificateId
        if (!batchDoc || !batchDoc.exists()) {
          const batchQ = query(
            collection(db, 'creditBatches'),
            where('certificateId', '==', referenceId),
            where('employeeId', '==', employeeId)
          );
          const batchSnap = await getDocs(batchQ);

          if (batchSnap.empty) {
            Modal.error('Error', 'COC certificate not found');
            return;
          }

          batchDoc = batchSnap.docs[0];
        }

        // Call the main view function with the found batch ID
        viewCocEarnedDetails(batchDoc.id);

      } catch (error) {
        console.error('Error viewing COC details:', error);
        Modal.error('Error', 'Failed to load COC details: ' + error.message);
      }
    };

    // View Historical Balance Details
    window.viewHistoricalBalanceDetails = async function(batchId) {
      try {
        const batchDoc = await getDoc(doc(db, 'creditBatches', batchId));

        if (!batchDoc.exists()) {
          Modal.error('Error', 'Historical balance record not found');
          return;
        }

        const batch = batchDoc.data();

        // Fetch employee details
        const employeeDoc = await getDoc(doc(db, 'employees', batch.employeeId));
        let employeeName = batch.employeeId;
        if (employeeDoc.exists()) {
          const emp = employeeDoc.data();
          employeeName = `${emp.firstName} ${emp.lastName}`;
          if (emp.suffix) {
            const needsComma = emp.suffix.toLowerCase().includes('jr') || emp.suffix.toLowerCase().includes('sr');
            employeeName += needsComma ? `, ${emp.suffix}` : ` ${emp.suffix}`;
          }
        }

        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
        const month = monthNames[batch.earnedMonth - 1] || 'Unknown';
        const year = batch.earnedYear || 'Unknown';
        const createdDate = batch.createdAt ? new Date(batch.createdAt).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' }) : 'N/A';

        Modal.custom({
          title: 'Historical Balance Details',
          icon: 'bi-clock-history',
          iconColor: 'text-info',
          message: `
            <div class="text-start">
              <table class="table table-bordered table-sm">
                <tbody>
                  <tr>
                    <th style="width: 35%;">Source</th>
                    <td><span class="badge bg-info">Historical Balance</span></td>
                  </tr>
                  <tr>
                    <th>Employee</th>
                    <td>${employeeName}</td>
                  </tr>
                  <tr>
                    <th>Employee ID</th>
                    <td>${batch.employeeId}</td>
                  </tr>
                  <tr>
                    <th>Earned Period</th>
                    <td><strong>${month} ${year}</strong></td>
                  </tr>
                  <tr>
                    <th>Hours Carried Over</th>
                    <td><strong class="text-info">${(batch.totalHours || batch.earnedHours || batch.initialHours || 0).toFixed(2)} hours</strong></td>
                  </tr>
                  <tr>
                    <th>Hours Used</th>
                    <td>${(batch.usedHours || 0).toFixed(2)} hours</td>
                  </tr>
                  <tr>
                    <th>Remaining Hours</th>
                    <td><strong class="text-primary">${(batch.remainingHours || 0).toFixed(2)} hours</strong></td>
                  </tr>
                  <tr>
                    <th>Recorded On</th>
                    <td>${createdDate}</td>
                  </tr>
                  <tr>
                    <th>Status</th>
                    <td><span class="badge ${batch.status === 'Active' ? 'bg-success' : batch.status === 'Expired' ? 'bg-secondary' : 'bg-warning'}">${batch.status}</span></td>
                  </tr>
                  ${batch.lastUsedDate ? `<tr><th>Last Used</th><td>${new Date(batch.lastUsedDate).toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td></tr>` : ''}
                  ${batch.remarks ? `<tr><th>Remarks</th><td>${batch.remarks}</td></tr>` : ''}
                </tbody>
              </table>
            </div>
          `,
          buttons: [
            {
              text: 'Close',
              class: 'btn-secondary',
              dismiss: true
            }
          ]
        });

      } catch (error) {
        console.error('Error viewing historical balance details:', error);
        Modal.error('Error', 'Failed to load historical balance details: ' + error.message);
      }
    };

    window.cancelCtoApplication = function(ledgerId, employeeName, hoursUsed) {
      Modal.custom({
        title: 'Cancel CTO Application',
        message: `
          <div class="text-start">
            <p class="mb-3">Are you sure you want to cancel this CTO application?</p>
            <div class="mb-3">
              <strong>Employee:</strong> ${employeeName}<br>
              <strong>Hours to Restore:</strong> ${Math.abs(hoursUsed).toFixed(1)} hours
            </div>
            <div class="mb-0">
              <label for="cancel-reason" class="form-label"><strong>Reason for Cancellation:</strong> <span class="text-danger">*</span></label>
              <textarea class="form-control" id="cancel-reason" rows="3" placeholder="Please provide a reason for cancelling this CTO application..." required>EXIGENCY OF SERVICE</textarea>
              <div class="text-danger small mt-1" id="cancel-reason-error" style="display: none;">Please provide a reason for cancellation.</div>
            </div>
            <div id="cancel-spinner-container" class="text-center mt-3" style="display: none;">
              <div class="spinner-border text-warning" role="status">
                <span class="visually-hidden">Cancelling...</span>
              </div>
              <p class="mt-2 text-muted">Cancelling CTO application...</p>
            </div>
          </div>
        `,
        icon: 'bi-exclamation-triangle-fill',
        iconColor: 'text-warning',
        buttons: [
          { text: 'Cancel', class: 'btn-secondary', dismiss: true, id: 'cancel-modal-btn' },
          {
            text: 'Yes, Cancel CTO',
            class: 'btn-warning',
            id: 'confirm-cancel-btn',
            callback: async function() {
              const reasonField = document.getElementById('cancel-reason');
              const errorMsg = document.getElementById('cancel-reason-error');
              const reason = reasonField.value.trim();

              if (!reason) {
                errorMsg.style.display = 'block';
                reasonField.classList.add('is-invalid');
                reasonField.focus();
                return false; // Prevent modal from closing
              }

              // Show spinner and disable buttons
              const spinnerContainer = document.getElementById('cancel-spinner-container');
              const confirmBtn = document.getElementById('confirm-cancel-btn');
              const cancelBtn = document.getElementById('cancel-modal-btn');

              spinnerContainer.style.display = 'block';
              reasonField.disabled = true;
              if (confirmBtn) confirmBtn.disabled = true;
              if (cancelBtn) cancelBtn.disabled = true;

              try {
                const result = await new Promise((resolve, reject) => {
                  google.script.run
                    .withSuccessHandler(resolve)
                    .withFailureHandler(reject)
                    .cancelCto_SERVER(ledgerId, reason);
                });

                // Hide spinner
                spinnerContainer.style.display = 'none';

                if (result.success) {
                  // Use custom message if provided (includes forfeit info)
                  const message = result.message || `Successfully cancelled CTO and restored ${result.hoursRestored.toFixed(1)} hours.`;
                  Modal.success('CTO Cancelled', message);
                  loadCtoApplications();
                  return true; // Close the modal
                } else {
                  // Re-enable buttons for retry
                  reasonField.disabled = false;
                  if (confirmBtn) confirmBtn.disabled = false;
                  if (cancelBtn) cancelBtn.disabled = false;
                  Modal.error('Error', result.error);
                  return false; // Keep modal open
                }
              } catch (error) {
                // Hide spinner and re-enable buttons
                spinnerContainer.style.display = 'none';
                reasonField.disabled = false;
                if (confirmBtn) confirmBtn.disabled = false;
                if (cancelBtn) cancelBtn.disabled = false;
                Modal.error('Error', 'Failed to cancel CTO: ' + error);
                return false; // Keep modal open
              }
            }
          }
        ],
        keyboard: true,
        clickOutsideToClose: false
      });

      // Add event listener to clear error when user types
      setTimeout(() => {
        const reasonField = document.getElementById('cancel-reason');
        const errorMsg = document.getElementById('cancel-reason-error');
        if (reasonField) {
          reasonField.addEventListener('input', function() {
            if (this.value.trim()) {
              errorMsg.style.display = 'none';
              this.classList.remove('is-invalid');
            }
          });
        }
      }, 100);
    };

    document.getElementById('ctoForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      // Validation: Filing date cannot be in the future
      if (!validateFilingDate()) {
        Modal.error('Invalid Filing Date', 'Filing date cannot be in the future.');
        return;
      }

      const ledgerId = document.getElementById('cto-ledger-id').value;
      const isEdit = ledgerId !== '';

      const hoursUsed = parseFloat(document.getElementById('cto-hours').value);
      const availableBalance = parseFloat(document.getElementById('cto-available-balance').textContent);

      // Validation: Total CTO hours should not exceed available balance
      if (hoursUsed > availableBalance) {
        Modal.error('Insufficient Balance', `Total CTO Application (${hoursUsed.toFixed(1)} hours) exceeds your available balance (${availableBalance.toFixed(1)} hours).`);
        return;
      }

      // Note: Restore remarks are optional for CTO editing
      // Remarks are only required for CTO cancellation

      const data = {
        employeeId: document.getElementById('cto-employee').value,
        filingDate: document.getElementById('cto-filing-date').value,
        dateFrom: document.getElementById('cto-date-from').value,
        dateTo: document.getElementById('cto-date-to').value,
        hoursUsed: hoursUsed,
        dayBreakdown: getDayBreakdown()
      };

      if (isEdit) {
        data.ledgerId = ledgerId;
        // Include restore remarks if provided (optional)
        const restoreRemarksValue = document.getElementById('cto-restore-remarks').value.trim();
        if (restoreRemarksValue) {
          data.restoreRemarks = restoreRemarksValue;
        }
      }

      const submitBtn = document.getElementById('cto-submit-btn');
      const btnText = submitBtn.querySelector('.btn-text');
      const spinner = submitBtn.querySelector('.spinner-border');

      try {
        // Show spinner
        submitBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const result = await new Promise((resolve, reject) => {
          const serverFunction = isEdit ? 'updateCto_SERVER' : 'logCto_SERVER';
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [serverFunction](data);
        });

        if (result.success) {
          const filingDate = new Date(data.filingDate);
          const formattedDate = filingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

          // Build batch info section
          let batchInfoHtml = '';
          if (result.creditedFrom && result.creditedFrom.length > 0) {
            batchInfoHtml = '<div class="mt-2 text-start"><p class="mb-1"><strong>Deducted from - Month & Year</strong></p><ul class="list-unstyled ms-3 mb-0">';
            result.creditedFrom.forEach(batch => {
              batchInfoHtml += `<li><i class="bi bi-arrow-right"></i> ${batch.hours.toFixed(1)} hrs - ${batch.month} ${batch.year}</li>`;
            });
            batchInfoHtml += '</ul></div>';
          }

          const title = isEdit ? 'CTO Updated!' : 'CTO Logged!';
          const message = `
            <div class="text-center">
              <h5 class="mb-1">Certification of Compensatory Overtime Credit (COC)</h5>
              <p class="text-muted mb-2">as of: <strong>${formattedDate}</strong></p>
              <table class="table table-bordered mt-2 text-start mx-auto mb-0" style="max-width: 500px;">
                <tbody>
                  <tr>
                    <td style="width: 50%;"><strong>No. of Hours of Earned:</strong></td>
                    <td><strong>${result.totalEarned.toFixed(1)}</strong> hrs</td>
                  </tr>
                  <tr>
                    <td><strong>Less CTO Application:</strong></td>
                    <td><strong class="text-danger">${result.hoursUsed.toFixed(1)}</strong> hrs</td>
                  </tr>
                  <tr class="table-primary">
                    <td><strong>Balance:</strong></td>
                    <td><strong class="text-primary">${result.newBalance.toFixed(1)}</strong> hrs</td>
                  </tr>
                </tbody>
              </table>
              ${batchInfoHtml}
            </div>
          `;
          ctoFormDirty = false; // Reset dirty flag
          Modal.success(title, message);
          cancelCtoEdit(); // Reset form

          // Refresh CTO list if on list tab
          const listTab = document.getElementById('cto-list-content');
          if (listTab && listTab.classList.contains('show') && listTab.classList.contains('active')) {
            loadCtoApplications();
          }
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error logging CTO: ' + error);
      } finally {
        // Hide spinner
        submitBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    });

    // Initialize CTO Calendar year dropdown
    (function() {
      const currentYear = new Date().getFullYear();
      const yearSelect = document.getElementById('cto-calendar-year');
      if (yearSelect) {
        for (let i = 0; i < 3; i++) {
          const year = currentYear - i;
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          if (i === 0) option.selected = true;
          yearSelect.appendChild(option);
        }
        // Set current month
        const monthSelect = document.getElementById('cto-calendar-month');
        if (monthSelect) {
          monthSelect.value = new Date().getMonth();
        }
      }
    })();

    // Track form changes for unsaved warning
    let ctoFormDirty = false;
    const ctoForm = document.getElementById('ctoForm');
    if (ctoForm) {
      ctoForm.addEventListener('input', () => {
        ctoFormDirty = true;
      });
      ctoForm.addEventListener('change', () => {
        ctoFormDirty = true;
      });
    }

    // Reset dirty flag when form is reset or submitted
    const originalCancelCtoEdit = window.cancelCtoEdit;
    window.cancelCtoEdit = function() {
      ctoFormDirty = false;
      originalCancelCtoEdit();
    };

    // Handle CTO tab switching with unsaved changes warning
    const ctoListTab = document.getElementById('cto-list-tab');
    const ctoCalendarTab = document.getElementById('cto-calendar-tab');

    if (ctoListTab) {
      ctoListTab.addEventListener('click', (e) => {
        // Warn about unsaved changes
        if (ctoFormDirty) {
          e.preventDefault();
          e.stopPropagation();

          // Show modal instead of confirm dialog
          Modal.custom({
            title: 'Unsaved Changes',
            icon: 'bi-exclamation-triangle',
            iconColor: 'text-warning',
            message: 'You have unsaved changes in the CTO form. Do you want to discard them?',
            buttons: [
              {
                text: 'Cancel',
                class: 'btn-secondary',
                dismiss: true
              },
              {
                text: 'Discard Changes',
                class: 'btn-danger',
                action: () => {
                  ctoFormDirty = false;
                  cancelCtoEdit();
                  // Trigger tab click again
                  requestAnimationFrame(() => {
                    ctoListTab.click();
                  });
                },
                dismiss: true
              }
            ]
          });
          return;
        }
        // Always refresh list when switching to list tab - use requestAnimationFrame for better responsiveness
        requestAnimationFrame(() => loadCtoApplications());
      });
    }

    if (ctoCalendarTab) {
      ctoCalendarTab.addEventListener('click', (e) => {
        // Warn about unsaved changes
        if (ctoFormDirty) {
          e.preventDefault();
          e.stopPropagation();

          // Show modal instead of confirm dialog
          Modal.custom({
            title: 'Unsaved Changes',
            icon: 'bi-exclamation-triangle',
            iconColor: 'text-warning',
            message: 'You have unsaved changes in the CTO form. Do you want to discard them?',
            buttons: [
              {
                text: 'Cancel',
                class: 'btn-secondary',
                dismiss: true
              },
              {
                text: 'Discard Changes',
                class: 'btn-danger',
                action: () => {
                  ctoFormDirty = false;
                  cancelCtoEdit();
                  // Trigger tab click again
                  requestAnimationFrame(() => {
                    ctoCalendarTab.click();
                  });
                },
                dismiss: true
              }
            ]
          });
          return;
        }
      });
    }

    // Load CTO Applications (Tab 2)
    window.loadCtoApplications = async function() {
      const loadingDiv = document.getElementById('cto-list-loading');
      const tbody = document.getElementById('ctoApplicationsTableBody');

      const employeeFilter = document.getElementById('cto-list-employee').value;
      const statusFilter = document.getElementById('cto-list-status').value;

      try {
        loadingDiv.style.display = 'block';
        tbody.innerHTML = '';

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getCtoApplications_SERVER();
        });

        loadingDiv.style.display = 'none';

        if (result.success && result.applications.length > 0) {
          // Apply filters
          let filteredApps = result.applications;

          if (employeeFilter) {
            filteredApps = filteredApps.filter(app => app.employeeId === employeeFilter);
          }

          if (statusFilter) {
            filteredApps = filteredApps.filter(app => (app.status || 'Active') === statusFilter);
          }

          // Sort by filing date descending (most recent first)
          filteredApps.sort((a, b) => new Date(b.filingDate) - new Date(a.filingDate));

          if (filteredApps.length > 0) {
            tbody.innerHTML = filteredApps.map(app => {
              const filingDate = new Date(app.filingDate);
              const dateFrom = new Date(app.inclusiveDateFrom);
              const dateTo = new Date(app.inclusiveDateTo);
              const status = app.status || 'Active';
              const statusBadge = status === 'Active'
                ? '<span class="badge bg-success">Active</span>'
                : '<span class="badge bg-secondary">Cancelled</span>';

              const actions = status === 'Active'
                ? `
                  <div class="d-flex gap-1 flex-nowrap">
                    <button class="btn btn-sm btn-outline-primary" onclick="editCtoApplication('${app.ledgerId}', this)" title="Edit">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="cancelCtoApplication('${app.ledgerId}', '${app.employeeName}', ${Math.abs(app.hoursChange)})" title="Cancel">
                      <i class="bi bi-x-circle"></i>
                    </button>
                  </div>
                `
                : '<span class="text-muted">-</span>';

              // Format deducted from info (FIFO)
              let deductedFromHtml = '<span class="text-muted">-</span>';
              if (app.deductedFrom && app.deductedFrom.length > 0) {
                deductedFromHtml = '<small>' + app.deductedFrom.map(batch =>
                  `${batch.hours.toFixed(1)} hrs - ${batch.month} ${batch.year}`
                ).join('<br>') + '</small>';
              }

              // Format remarks - show cancellation reason if cancelled
              let remarksHtml = '<span class="text-muted">-</span>';
              if (status === 'Cancelled' && app.cancellationReason) {
                remarksHtml = `<small class="text-danger"><strong>Cancelled:</strong> ${app.cancellationReason}</small>`;
              }

              // Add styling for cancelled rows
              const rowStyle = status === 'Cancelled' ? 'style="background-color: #fff3cd;"' : '';

              return `
                <tr ${rowStyle}>
                  <td>${filingDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</td>
                  <td>${app.employeeName}</td>
                  <td>${dateFrom.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${dateTo.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</td>
                  <td><strong class="text-danger">${Math.abs(app.hoursChange).toFixed(1)}</strong> hrs</td>
                  <td>${deductedFromHtml}</td>
                  <td><strong class="text-primary">${app.balanceAfter.toFixed(1)}</strong> hrs</td>
                  <td>${statusBadge}</td>
                  <td>${remarksHtml}</td>
                  <td>${actions}</td>
                </tr>
              `;
            }).join('');
          } else {
            tbody.innerHTML = '<tr><td colspan="9" class="text-center">No CTO applications match the selected filters</td></tr>';
          }
        } else {
          tbody.innerHTML = '<tr><td colspan="9" class="text-center">No CTO applications found</td></tr>';
        }
      } catch (error) {
        loadingDiv.style.display = 'none';
        tbody.innerHTML = '<tr><td colspan="9" class="text-center text-danger">Error loading applications</td></tr>';
        Modal.error('Error', 'Failed to load CTO applications: ' + error);
      }
    };

    // Load CTO Calendar (Tab 3)
    window.loadCtoCalendar = async function() {
      const loadingDiv = document.getElementById('cto-calendar-loading');
      const container = document.getElementById('cto-calendar-container');
      const month = parseInt(document.getElementById('cto-calendar-month').value);
      const year = parseInt(document.getElementById('cto-calendar-year').value);

      try {
        loadingDiv.style.display = 'block';
        container.innerHTML = '';

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getCtoCalendar_SERVER({ month, year });
        });

        loadingDiv.style.display = 'none';

        if (result.success) {
          // Generate calendar
          const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December'];

          let html = `<h5 class="mb-3">${monthNames[month]} ${year}</h5>`;
          html += '<div class="table-responsive"><table class="table table-bordered table-sm">';
          html += '<thead><tr><th>Sun</th><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th></tr></thead><tbody>';

          const firstDay = new Date(year, month, 1).getDay();
          const daysInMonth = new Date(year, month + 1, 0).getDate();

          let day = 1;
          for (let i = 0; i < 6; i++) {
            if (day > daysInMonth) break;
            html += '<tr>';
            for (let j = 0; j < 7; j++) {
              if ((i === 0 && j < firstDay) || day > daysInMonth) {
                html += '<td class="text-muted"></td>';
              } else {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const ctos = result.ctosByDate[dateStr] || [];

                let cellClass = '';
                let cellContent = `<div class="fw-bold">${day}</div>`;

                if (ctos.length > 0) {
                  cellClass = 'bg-info bg-opacity-10';
                  cellContent += '<div class="small">';
                  ctos.forEach(cto => {
                    cellContent += `<div class="badge bg-primary me-1">${cto.employeeName}</div>`;
                  });
                  cellContent += '</div>';
                }

                html += `<td class="${cellClass}" style="vertical-align: top; min-height: 80px;">${cellContent}</td>`;
                day++;
              }
            }
            html += '</tr>';
          }

          html += '</tbody></table></div>';

          if (result.totalApplications > 0) {
            html += `<div class="alert alert-info mt-3">Total CTOs in ${monthNames[month]}: <strong>${result.totalApplications}</strong></div>`;
          }

          container.innerHTML = html;
        } else {
          container.innerHTML = '<div class="alert alert-warning">No data available</div>';
        }
      } catch (error) {
        loadingDiv.style.display = 'none';
        container.innerHTML = '<div class="alert alert-danger">Error loading calendar</div>';
        Modal.error('Error', 'Failed to load CTO calendar: ' + error);
      }
    };

    document.getElementById('historicalForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const form = e.target;
      const submitBtn = document.getElementById('hist-submit-btn');
      const btnText = submitBtn.querySelector('.btn-text');
      const spinner = submitBtn.querySelector('.spinner-border');

      form.classList.add('was-validated');

      if (!form.checkValidity()) {
        return;
      }

      const cocEarned = parseFloat(document.getElementById('hist-coc-earned').value);
      const cocUsed = parseFloat(document.getElementById('hist-coc-used').value) || 0;

      // Additional validation
      if (cocUsed > cocEarned) {
        Modal.error('Validation Error', 'COC Used cannot exceed COC Earned');
        return;
      }

      if (cocUsed > 0 && cocUsed % 4 !== 0) {
        Modal.error('Validation Error', 'COC Used must be in blocks of 4 hours (4, 8, 12, 16, etc.)');
        return;
      }

      const isEdit = document.getElementById('hist-is-edit').value === 'true';
      const batchId = document.getElementById('hist-batch-id').value;

      const data = {
        employeeId: document.getElementById('hist-employee').value,
        monthYear: document.getElementById('hist-month-year').value,
        cocEarned: cocEarned,
        cocUsed: cocUsed,
        dateOfIssuance: document.getElementById('hist-date-issuance').value
      };

      if (isEdit) {
        data.batchId = batchId;
      }

      // Show spinner
      submitBtn.disabled = true;
      btnText.classList.add('d-none');
      spinner.classList.remove('d-none');

      try {
        const serverFunction = isEdit ? 'updateHistoricalBalance_SERVER' : 'migrateHistoricalBalance_SERVER';
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [serverFunction](data);
        });

        if (result.success) {
          const message = `
            <div class="text-center">
              <table class="table table-bordered mt-3 text-start mx-auto" style="max-width: 500px;">
                <tbody>
                  <tr>
                    <td style="width: 40%;"><strong>Remaining Balance</strong></td>
                    <td><strong class="text-primary">${result.remainingHours}</strong> hours</td>
                  </tr>
                  <tr>
                    <td><strong>Valid Until</strong></td>
                    <td>${result.validUntil}</td>
                  </tr>
                  <tr>
                    <td><strong>Status</strong></td>
                    <td><span class="badge bg-success">${result.status}</span></td>
                  </tr>
                </tbody>
              </table>
            </div>
          `;
          Modal.success(isEdit ? 'Historical Balance Updated!' : 'Historical Balance Migrated!', message);

          // Reset form using reset function
          resetHistoricalForm();

          // The list will auto-update via onSnapshot listener
        } else {
          Modal.error('Migration Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error migrating balance: ' + error);
      } finally {
        // Hide spinner
        submitBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    });

    document.getElementById('configForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const data = {
        regularDayMultiplier: parseFloat(document.getElementById('config-regular').value),
        restDayMultiplier: parseFloat(document.getElementById('config-restday').value),
        holidayMultiplier: parseFloat(document.getElementById('config-holiday').value),
        monthlyAccrualCap: parseInt(document.getElementById('config-monthly-cap').value),
        totalBalanceCap: parseInt(document.getElementById('config-total-cap').value),
        expiryMonths: parseInt(document.getElementById('config-expiry-months').value)
      };

      const submitBtn = document.getElementById('config-submit-btn');
      const btnText = submitBtn.querySelector('.btn-text');
      const spinner = submitBtn.querySelector('.spinner-border');

      try {
        // Show spinner
        submitBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .saveConfiguration_SERVER(data);
        });

        if (result.success) {
          Modal.success('Success!', 'Configuration saved successfully!');
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving configuration: ' + error);
      } finally {
        // Hide spinner
        submitBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    });

    window.resetEmployeeForm = function() {
      const form = document.getElementById('employeeForm');
      form.reset();
      form.classList.remove('was-validated');
      document.querySelectorAll('.form-control, .form-select').forEach(el => {
        el.classList.remove('is-invalid');
      });
      document.getElementById('emp-id-hidden').value = '';
      document.getElementById('emp-id-display').style.display = 'none';
      document.getElementById('employeeModalTitle').textContent = 'Add Employee';
      document.getElementById('emp-status').value = 'Active';
    };

    window.saveEmployee = async function() {
      const form = document.getElementById('employeeForm');
      const saveBtn = document.getElementById('saveEmployeeBtn');
      const btnText = saveBtn.querySelector('.btn-text');
      const spinner = saveBtn.querySelector('.spinner-border');
      
      document.querySelectorAll('.form-control, .form-select').forEach(el => {
        el.classList.remove('is-invalid');
      });

      const requiredFields = [
        { id: 'emp-fname', name: 'First Name' },
        { id: 'emp-lname', name: 'Last Name' },
        { id: 'emp-office', name: 'Office' },
        { id: 'emp-position', name: 'Position' },
        { id: 'emp-status', name: 'Status' }
      ];

      let hasErrors = false;
      requiredFields.forEach(field => {
        const element = document.getElementById(field.id);
        if (!element.value || element.value.trim() === '') {
          element.classList.add('is-invalid');
          hasErrors = true;
        }
      });

      if (hasErrors) {
        return;
      }

      const isUpdate = document.getElementById('emp-id-hidden').value !== '';
      const employeeId = document.getElementById('emp-id-hidden').value;
      const statusValue = document.getElementById('emp-status').value;
      
      const data = {
        firstName: document.getElementById('emp-fname').value,
        lastName: document.getElementById('emp-lname').value,
        middleName: document.getElementById('emp-mname').value,
        suffix: document.getElementById('emp-suffix').value,
        office: document.getElementById('emp-office').value,
        position: document.getElementById('emp-position').value,
        isActive: statusValue === 'Active'
      };

      try {
        saveBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const result = await new Promise((resolve, reject) => {
          if (isUpdate) {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .updateEmployee_SERVER(employeeId, data);
          } else {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .addEmployee_SERVER(data);
          }
        });

        if (result.success) {
          const title = isUpdate ? 'Employee Updated!' : 'Employee Added!';
          let message;
          if (isUpdate) {
            message = `
              <div class="text-center">
                <table class="table table-bordered mt-3 text-start mx-auto" style="max-width: 500px;">
                  <tbody>
                    <tr>
                      <td><strong>Status</strong></td>
                      <td>Employee information updated successfully</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            `;
          } else {
            message = `
              <div class="text-center">
                <table class="table table-bordered mt-3 text-start mx-auto" style="max-width: 500px;">
                  <tbody>
                    <tr>
                      <td style="width: 40%;"><strong>Employee ID</strong></td>
                      <td><code>${result.employeeId}</code></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            `;
          }
          Modal.success(title, message);
          bootstrap.Modal.getInstance(document.getElementById('employeeModal')).hide();
          form.reset();

          // Refresh the currently active tab to show updated employee list
          const activeTab = document.querySelector('#employeeTabs .nav-link.active');
          if (activeTab) {
            const activeTabHref = activeTab.getAttribute('href');
            if (activeTabHref === '#active-employees-tab') {
              renderEmployeesTable('active');
            } else if (activeTabHref === '#inactive-employees-tab') {
              renderEmployeesTable('inactive');
            }
          }
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving employee: ' + error);
      } finally {
        saveBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    };

    window.editEmployee = function(employeeId) {
      const emp = employeesData.find(e => e.employeeId === employeeId);
      if (!emp) return;

      document.getElementById('emp-id-hidden').value = employeeId;
      document.getElementById('emp-id-text').textContent = employeeId;
      document.getElementById('emp-id-display').style.display = 'block';
      document.getElementById('emp-fname').value = emp.firstName;
      document.getElementById('emp-mname').value = emp.middleName || '';
      document.getElementById('emp-lname').value = emp.lastName;
      document.getElementById('emp-suffix').value = emp.suffix || '';
      document.getElementById('emp-office').value = emp.office;
      document.getElementById('emp-position').value = emp.position;
      document.getElementById('emp-status').value = emp.isActive ? 'Active' : 'Inactive';
      
      document.getElementById('employeeModalTitle').textContent = 'Edit Employee';
      
      new bootstrap.Modal(document.getElementById('employeeModal')).show();
    };

    window.resetHolidayForm = function() {
      document.getElementById('holidayForm').reset();
      document.getElementById('hol-id').value = '';
      document.getElementById('holidayModalTitle').textContent = 'Add Holiday';
    };

    window.editHoliday = async function(holidayId) {
      try {
        const db = getFirestore();
        const docRef = doc(db, 'holidays', holidayId);
        const docSnap = await getDoc(docRef);

        if (!docSnap.exists()) {
          Modal.error('Error', 'Holiday not found');
          return;
        }

        const hol = docSnap.data();

        // Populate form with existing data
        document.getElementById('hol-id').value = holidayId;
        document.getElementById('hol-date').value = hol.date;
        document.getElementById('hol-name').value = hol.name;
        document.getElementById('hol-type').value = hol.type;
        document.getElementById('hol-recurring').checked = hol.isRecurring || false;

        // Update modal title
        document.getElementById('holidayModalTitle').textContent = 'Edit Holiday';

        // Show modal
        new bootstrap.Modal(document.getElementById('holidayModal')).show();
      } catch (error) {
        Modal.error('Error', 'Error loading holiday: ' + error);
      }
    };

    window.saveHoliday = async function() {
      const form = document.getElementById('holidayForm');
      if (!form.checkValidity()) {
        form.reportValidity();
        return;
      }

      const holidayId = document.getElementById('hol-id').value;
      const isEdit = !!holidayId;

      const data = {
        date: document.getElementById('hol-date').value,
        name: document.getElementById('hol-name').value,
        type: document.getElementById('hol-type').value,
        isRecurring: document.getElementById('hol-recurring').checked
      };

      if (isEdit) {
        data.holidayId = holidayId;
      }

      const saveBtn = document.getElementById('saveHolidayBtn');
      const btnText = saveBtn.querySelector('.btn-text');
      const spinner = saveBtn.querySelector('.spinner-border');

      try {
        // Show spinner
        saveBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const serverFunction = isEdit ? 'updateHoliday_SERVER' : 'addHoliday_SERVER';
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [serverFunction](data);
        });

        if (result.success) {
          Modal.success('Success!', `Holiday ${isEdit ? 'updated' : 'added'} successfully!`);
          bootstrap.Modal.getInstance(document.getElementById('holidayModal')).hide();
          form.reset();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', `Error ${isEdit ? 'updating' : 'adding'} holiday: ` + error);
      } finally {
        // Hide spinner
        saveBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    };

    window.deleteHoliday = async function(holidayId) {
      Modal.confirm(
        'Delete Holiday',
        'Are you sure you want to delete this holiday? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteHoliday_SERVER(holidayId);
            });

            if (result.success) {
              Modal.success('Success!', 'Holiday deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting holiday: ' + error);
          }
        }
      );
    };

    document.addEventListener('DOMContentLoaded', () => {
      initFirebase();

      // Lazy rendering for employee tabs - only render when tab is shown
      document.querySelector('a[href="#active-employees-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderEmployeesTable('active');
      });

      document.querySelector('a[href="#inactive-employees-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderEmployeesTable('inactive');
      });

      // Lazy rendering for library tabs - only render when tab is shown
      document.querySelector('a[href="#offices-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderLibraryTable('offices');
      });

      document.querySelector('a[href="#positions-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderLibraryTable('positions');
      });

      document.querySelector('a[href="#signatory-tab"]')?.addEventListener('shown.bs.tab', function() {
        loadSignatory();
      });

      // Fix for Bootstrap tabs not firing correctly on first click
      document.querySelectorAll('#employeeTabs a[data-bs-toggle="tab"], #libraryTabs a[data-bs-toggle="tab"]').forEach(tabEl => {
        tabEl.addEventListener('click', function (event) {
          event.preventDefault(); // Ensure default href jump is stopped
          try {
            // 'this' is the clicked a[data-bs-toggle="tab"]
            const tab = new bootstrap.Tab(this);
            tab.show();
          } catch (e) {
            console.error('Error showing tab:', e);
          }
        });
      });

      // Fix dropdown hover state persistence
      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', function() {
          this.blur();
          // Close the dropdown
          const dropdown = this.closest('.dropdown');
          if (dropdown) {
            const toggle = dropdown.querySelector('[data-bs-toggle="dropdown"]');
            if (toggle) {
              bootstrap.Dropdown.getInstance(toggle)?.hide();
            }
          }
        });
      });
    });

    window.showAddLibraryModal = function(type) {
      document.getElementById('lib-item-id').value = '';
      document.getElementById('lib-type').value = type;
      document.getElementById('lib-name').value = '';
      
      const typeName = type === 'offices' ? 'Office' : 'Position';
      document.getElementById('libraryModalTitle').textContent = `Add ${typeName}`;
      document.getElementById('libraryItemLabel').textContent = `${typeName} Name`;
      
      new bootstrap.Modal(document.getElementById('libraryModal')).show();
    };

    window.editLibraryItem = function(type, itemId, currentName) {
      document.getElementById('lib-item-id').value = itemId;
      document.getElementById('lib-type').value = type;
      document.getElementById('lib-name').value = currentName;
      
      const typeName = type === 'offices' ? 'Office' : 'Position';
      document.getElementById('libraryModalTitle').textContent = `Edit ${typeName}`;
      document.getElementById('libraryItemLabel').textContent = `${typeName} Name`;
      
      new bootstrap.Modal(document.getElementById('libraryModal')).show();
    };

    window.saveLibraryItem = async function() {
      const form = document.getElementById('libraryForm');
      if (!form.checkValidity()) {
        form.reportValidity();
        return;
      }

      const itemId = document.getElementById('lib-item-id').value;
      const type = document.getElementById('lib-type').value;
      const name = document.getElementById('lib-name').value;

      const saveBtn = document.getElementById('saveLibraryBtn');
      const btnText = saveBtn.querySelector('.btn-text');
      const spinner = saveBtn.querySelector('.spinner-border');

      try {
        // Show spinner
        saveBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const isUpdate = itemId !== '';
        const result = await new Promise((resolve, reject) => {
          if (isUpdate) {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .updateLibraryItem_SERVER(type, itemId, { name });
          } else {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .addLibraryItem_SERVER(type, { name });
          }
        });

        if (result.success) {
          const title = isUpdate ? 'Item Updated!' : 'Item Added!';
          Modal.success(title, isUpdate ? 'Item updated successfully!' : 'Item added successfully!');
          bootstrap.Modal.getInstance(document.getElementById('libraryModal')).hide();
          form.reset();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving item: ' + error);
      } finally {
        // Hide spinner
        saveBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    };

    window.deleteLibraryItem = async function(type, itemId, itemName) {
      Modal.confirm(
        'Delete Item',
        `Are you sure you want to delete "${itemName}"? This action cannot be undone.`,
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteLibraryItem_SERVER(type, itemId);
            });

            if (result.success) {
              Modal.success('Success!', 'Item deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting item: ' + error);
          }
        }
      );
    };

    // Signatory Configuration Functions
    window.loadSignatory = async function() {
      const loadingDiv = document.getElementById('signatory-loading');
      const form = document.getElementById('signatoryForm');
      const nameInput = document.getElementById('signatory-name');
      const positionInput = document.getElementById('signatory-position');

      try {
        // Show loading, hide form
        loadingDiv.style.display = 'block';
        form.style.display = 'none';

        // Get signatory document from Firestore
        const docRef = doc(db, 'libraries', 'signatory');
        const docSnap = await getDoc(docRef);

        // Hide loading, show form
        loadingDiv.style.display = 'none';
        form.style.display = 'block';

        if (docSnap.exists()) {
          const data = docSnap.data();
          nameInput.value = data.name || '';
          positionInput.value = data.position || '';
        } else {
          // No signatory configured yet
          nameInput.value = '';
          positionInput.value = '';
        }
      } catch (error) {
        loadingDiv.style.display = 'none';
        form.style.display = 'block';
        console.error('Error loading signatory:', error);
        Modal.error('Error', 'Failed to load signatory information: ' + error.message);
      }
    };

    window.saveSignatory = async function() {
      const nameInput = document.getElementById('signatory-name');
      const positionInput = document.getElementById('signatory-position');

      const name = nameInput.value.trim();
      const position = positionInput.value.trim();

      // Validation
      if (!name) {
        Modal.error('Validation Error', 'Please enter the signatory name');
        nameInput.focus();
        return;
      }

      if (!position) {
        Modal.error('Validation Error', 'Please enter the signatory position/title');
        positionInput.focus();
        return;
      }

      // Check max 4 lines for position
      const lines = position.split('\n');
      if (lines.length > 4) {
        Modal.error('Validation Error', 'Signatory position cannot exceed 4 lines. Please reduce the number of lines.');
        positionInput.focus();
        return;
      }

      try {
        // Name is already uppercase from the input field (real-time conversion)
        // Save to Firestore
        const docRef = doc(db, 'libraries', 'signatory');
        await setDoc(docRef, {
          category: 'signatory',
          name: name,  // Already uppercase from input field
          position: position,
          updatedAt: new Date().toISOString(),
          updatedBy: auth.currentUser?.email || 'Unknown'
        });

        Modal.success('Success!', 'Signatory configuration saved successfully!');
      } catch (error) {
        console.error('Error saving signatory:', error);
        Modal.error('Error', 'Failed to save signatory configuration: ' + error.message);
      }
    };

    // Fix for active state on page navigation
    document.querySelectorAll('a[data-page]').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const page = this.dataset.page;

        document.querySelectorAll('.page-view').forEach(p => p.classList.remove('active'));
        document.getElementById(`page-${page}`).classList.add('active');

        // Remove active class from ALL nav links first
        document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));

        // Add active class to the clicked link
        this.classList.add('active');

        // Check if the link is inside a dropdown
        const dropdownMenu = this.closest('.dropdown-menu');
        if (dropdownMenu) {
          // If it is, add 'active' to the dropdown toggle as well
          const dropdownToggle = dropdownMenu.previousElementSibling;
          if (dropdownToggle && dropdownToggle.classList.contains('dropdown-toggle')) {
            dropdownToggle.classList.add('active');
          }
        }

        // Set default active tabs for Employees, Libraries, and Generate Certificate pages
        if (page === 'employees') {
          // Activate the "Active Employees" tab
          const activeTab = document.querySelector('a[href="#active-employees-tab"]');
          if (activeTab) {
            const tab = new bootstrap.Tab(activeTab);
            tab.show();
          }
        } else if (page === 'libraries') {
          // Activate the "Offices" tab
          const officesTab = document.querySelector('a[href="#offices-tab"]');
          if (officesTab) {
            const tab = new bootstrap.Tab(officesTab);
            tab.show();
          }
        } else if (page === 'generate-cert') {
          // Activate the "By Employee" tab
          const certEmployeeTab = document.getElementById('cert-employee-tab');
          if (certEmployeeTab) {
            const tab = new bootstrap.Tab(certEmployeeTab);
            tab.show();
          }
        } else if (page === 'log-overtime') {
          // Refresh overtime context to validate current selection
          if (typeof updateOvertimeContext === 'function') {
            updateOvertimeContext();
          }
        } else if (page === 'view-certificates') {
          // Load certificates with current filters (defaults to All Years)
          if (typeof loadCertificates === 'function') {
            loadCertificates();
          }
        } else if (page === 'log-cto') {
          // Activate the "Log CTO Application" tab
          const ctoLogTab = document.getElementById('cto-log-tab');
          if (ctoLogTab) {
            const tab = new bootstrap.Tab(ctoLogTab);
            tab.show();
          }
        }
      });
    });
  </script>
