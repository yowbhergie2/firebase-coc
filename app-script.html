  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, onSnapshot, doc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    let db, auth, currentUser;
    let employeesData = [];
    let unsubscribers = [];
    let librariesData = { offices: [], positions: [] };
    let employeeSearchTerms = { active: '', inactive: '' };
    let librarySearchTerms = { offices: '', positions: '' };

    // Helper to check if tab is currently visible
    function isTabVisible(tabId) {
      const tab = document.querySelector(`#${tabId}`);
      return tab && tab.classList.contains('show') && tab.classList.contains('active');
    }

    window.Modal = {
      _instance: null,
      _callback: null,

      _show(config) {
        const modalEl = document.getElementById('universalModal');
        const bodyEl = document.getElementById('universalModalBody');
        const footerEl = document.getElementById('universalModalFooter');

        bodyEl.innerHTML = `
          <div class="mb-3">
            <i class="bi ${config.icon} ${config.iconColor}" style="font-size: 4rem;"></i>
          </div>
          <h5 class="modal-title mb-3">${config.title}</h5>
          <p class="text-muted mb-0">${config.message}</p>
        `;

        footerEl.innerHTML = '';
        config.buttons.forEach(btn => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `btn ${btn.class} px-4`;
          button.textContent = btn.text;
          
          if (btn.dismiss) {
            button.setAttribute('data-bs-dismiss', 'modal');
          }
          
          if (btn.callback) {
            button.onclick = () => {
              if (this._instance) {
                this._instance.hide();
              }
              btn.callback();
            };
          } else if (btn.dismiss) {
          }
          
          footerEl.appendChild(button);
        });

        if (this._instance) {
          this._instance.dispose();
        }
        
        this._instance = new bootstrap.Modal(modalEl, {
          backdrop: config.backdrop !== false ? 'static' : true,
          keyboard: config.keyboard !== false
        });

        if (config.clickOutsideToClose) {
          modalEl.addEventListener('click', (e) => {
            if (e.target === modalEl) {
              this._instance.hide();
            }
          });
        }

        if (config.keyboard !== false) {
          const escHandler = (e) => {
            if (e.key === 'Escape' && this._instance) {
              this._instance.hide();
              modalEl.removeEventListener('keydown', escHandler);
            }
          };
          modalEl.addEventListener('keydown', escHandler);
        }

        this._instance.show();
      },

      success(title, message, callback) {
        this._show({
          title: title || 'Success!',
          message: message || '',
          icon: 'bi-check-circle-fill',
          iconColor: 'text-success',
          buttons: [
            { text: 'OK', class: 'btn-success', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      error(title, message, callback) {
        this._show({
          title: title || 'Error',
          message: message || '',
          icon: 'bi-x-circle-fill',
          iconColor: 'text-danger',
          buttons: [
            { text: 'OK', class: 'btn-danger', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      warning(title, message, callback) {
        this._show({
          title: title || 'Warning',
          message: message || '',
          icon: 'bi-exclamation-triangle-fill',
          iconColor: 'text-warning',
          buttons: [
            { text: 'OK', class: 'btn-warning', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      info(title, message, callback) {
        this._show({
          title: title || 'Information',
          message: message || '',
          icon: 'bi-info-circle-fill',
          iconColor: 'text-info',
          buttons: [
            { text: 'OK', class: 'btn-info', dismiss: true, callback: callback }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      confirm(title, message, onConfirm, onCancel) {
        this._show({
          title: title || 'Confirm Action',
          message: message || 'Are you sure?',
          icon: 'bi-question-circle-fill',
          iconColor: 'text-warning',
          buttons: [
            { text: 'Cancel', class: 'btn-secondary', dismiss: true, callback: onCancel },
            { text: 'Yes, Continue', class: 'btn-warning', callback: onConfirm }
          ],
          keyboard: true,
          clickOutsideToClose: false
        });
      },

      custom(config) {
        const defaults = {
          title: 'Modal',
          message: '',
          icon: 'bi-info-circle-fill',
          iconColor: 'text-primary',
          buttons: [
            { text: 'OK', class: 'btn-primary', dismiss: true }
          ],
          keyboard: true,
          clickOutsideToClose: false,
          backdrop: true
        };
        
        const finalConfig = { ...defaults, ...config };
        this._show(finalConfig);
      }
    };

    async function initFirebase() {
      try {
        console.log('Starting Firebase initialization...');
        
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getFirebaseConfigAndToken();
        });

        console.log('Received Firebase config and token');
        
        const app = initializeApp(result.config);
        auth = getAuth(app);
        db = getFirestore(app);

        console.log('Signing in with custom token...');
        await signInWithCustomToken(auth, result.token);
        currentUser = auth.currentUser;
        
        console.log('Firebase authentication successful');
        document.getElementById('userEmail').innerHTML = `<i class="bi bi-person-circle"></i> ${result.userEmail}`;

        loadAllData();
      } catch (error) {
        console.error('Firebase init error:', error);
        Modal.error('Firebase Error', 'Error initializing Firebase: ' + error.message);
      }
    }

    function loadAllData() {
      loadEmployees();
      loadDashboard();
      loadHolidays();
      loadConfiguration();
      loadLibraries();
      // loadHistoricalBalances is now called when an employee is selected
    }

    function loadEmployees() {
      const q = query(collection(db, 'employees'), orderBy('lastName'));
      const unsubscribe = onSnapshot(q, (snapshot) => {
        employeesData = [];
        snapshot.forEach((doc) => {
          employeesData.push({ id: doc.id, ...doc.data() });
        });

        populateEmployeeDropdowns();
        // Only render the active tab initially for better performance
        renderEmployeesTable('active');
      });
      unsubscribers.push(unsubscribe);
    }

    function populateEmployeeDropdowns() {
      // Regular dropdowns (except ot-employee and hist-employee which are now searchable)
      const dropdowns = ['cert-employee', 'ledger-employee', 'cto-employee'];
      dropdowns.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
          select.innerHTML = '<option value="">Select Employee</option>';
          employeesData.forEach(emp => {
            if (emp.isActive) {
              select.innerHTML += `<option value="${emp.employeeId}">${emp.lastName}, ${emp.firstName} (${emp.employeeId})</option>`;
            }
          });
        }
      });

      // Populate searchable dropdowns
      populateOvertimeEmployeeDropdown();
      populateHistoricalEmployeeDropdown();
      populateHistoricalEmployeeFilterDropdown();
      renderEmployeesWithoutHistoricalBalance();
    }

    function populateOvertimeEmployeeDropdown() {
      const dropdown = document.getElementById('ot-employee-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}', '${emp.office}', '${emp.position}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterOvertimeEmployees = function() {
      const searchInput = document.getElementById('ot-employee-search');
      const dropdown = document.getElementById('ot-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          const office = (emp.office || '').toLowerCase();
          const position = (emp.position || '').toLowerCase();

          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm) ||
                 office.includes(searchTerm) ||
                 position.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}', '${emp.office}', '${emp.position}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showOvertimeEmployeeDropdown();
    };

    window.showOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      dropdown.style.display = 'block';
    };

    window.hideOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      dropdown.style.display = 'none';
    };

    window.selectOvertimeEmployee = function(employeeId, name, office, position) {
      const searchInput = document.getElementById('ot-employee-search');
      const hiddenInput = document.getElementById('ot-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideOvertimeEmployeeDropdown();
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const container = document.querySelector('.searchable-select-container');
      const dropdown = document.getElementById('ot-employee-dropdown');

      if (container && dropdown && !container.contains(event.target)) {
        hideOvertimeEmployeeDropdown();
      }
    });

    function renderEmployeesTable(type) {
      // If no type specified, render both (for initial load only)
      const typesToRender = type ? [type] : ['active', 'inactive'];

      typesToRender.forEach(tabType => {
        const employees = employeesData.filter(emp =>
          tabType === 'active' ? emp.isActive : !emp.isActive
        );

        // Apply search filter
        let filteredEmployees = employees;
        const searchTerm = employeeSearchTerms[tabType];

        if (searchTerm) {
          const searchLower = searchTerm.toLowerCase();
          filteredEmployees = employees.filter(emp => {
            const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
            const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
            return fullName.includes(searchLower) ||
                   reverseName.includes(searchLower) ||
                   (emp.office && emp.office.toLowerCase().includes(searchLower)) ||
                   (emp.position && emp.position.toLowerCase().includes(searchLower));
          });
        }

        const tableBody = document.getElementById(`${tabType}EmployeesTableBody`);

        if (filteredEmployees.length === 0) {
          const message = searchTerm ? 'No employees match your search' : `No ${tabType} employees found`;
          tableBody.innerHTML = `<tr><td colspan="5" class="text-center">${message}</td></tr>`;
        } else {
          tableBody.innerHTML = filteredEmployees.map(emp => `
            <tr>
              <td>${emp.employeeId}</td>
              <td>${emp.lastName}, ${emp.firstName}</td>
              <td>${emp.office}</td>
              <td>${emp.position}</td>
              <td>
                <button class="btn btn-sm btn-outline-primary me-1" onclick="editEmployee('${emp.employeeId}')">
                  <i class="bi bi-pencil"></i> Edit
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteEmployee('${emp.employeeId}')">
                  <i class="bi bi-trash"></i> Delete
                </button>
              </td>
            </tr>
          `).join('');
        }
      });
    }

    window.deleteEmployee = async function(employeeId) {
      Modal.confirm(
        'Delete Employee',
        'Are you sure you want to delete this employee? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteEmployee_SERVER(employeeId);
            });

            if (result.success) {
              Modal.success('Success!', 'Employee deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting employee: ' + error);
          }
        }
      );
    };

    window.filterEmployees = function(type) {
      const searchInput = document.getElementById(`search-${type}-employees`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      employeeSearchTerms[type] = searchInput.value;

      // Show/hide clear button
      if (searchInput.value) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }

      // Only render the specific tab being filtered
      renderEmployeesTable(type);
    };

    window.clearEmployeeSearch = function(type) {
      const searchInput = document.getElementById(`search-${type}-employees`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      searchInput.value = '';
      employeeSearchTerms[type] = '';
      clearBtn.classList.remove('visible');

      // Only render the specific tab being cleared
      renderEmployeesTable(type);
    };

    // Historical Balance Employee Dropdown Functions
    // Employee Filter Dropdown (Main selector)
    let selectedHistoricalEmployee = null;

    function populateHistoricalEmployeeFilterDropdown() {
      const dropdown = document.getElementById('hist-employee-filter-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterHistoricalEmployeeFilter = function() {
      const searchInput = document.getElementById('hist-employee-filter-search');
      const dropdown = document.getElementById('hist-employee-filter-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showHistoricalEmployeeFilterDropdown();
    };

    window.showHistoricalEmployeeFilterDropdown = function() {
      const dropdown = document.getElementById('hist-employee-filter-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideHistoricalEmployeeFilterDropdown = function() {
      const dropdown = document.getElementById('hist-employee-filter-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectHistoricalEmployeeFilter = function(employeeId, name) {
      const searchInput = document.getElementById('hist-employee-filter-search');
      const hiddenInput = document.getElementById('hist-employee-filter');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;
      selectedHistoricalEmployee = employeeId;

      hideHistoricalEmployeeFilterDropdown();

      // Show content section and pre-fill form
      document.getElementById('hist-content-section').style.display = 'block';
      document.getElementById('hist-employee-name').value = `${name} (${employeeId})`;
      document.getElementById('hist-employee').value = employeeId;

      // Activate the "Add Historical Balance" tab as default
      const addTab = document.getElementById('tab-add-hist');
      if (addTab) {
        addTab.click();
      }

      // Load historical balances for this employee
      loadHistoricalBalances();

      // Check if employee has overtime logs and disable historical balance actions
      checkEmployeeHasOvertimeLogs(employeeId);
    };

    async function checkEmployeeHasOvertimeLogs(employeeId) {
      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .checkEmployeeHasOvertimeLogs_SERVER(employeeId);
        });

        if (result.hasLogs) {
          // Disable form fields
          document.getElementById('hist-month-year').disabled = true;
          document.getElementById('hist-date-issuance').disabled = true;
          document.getElementById('hist-coc-earned').disabled = true;
          document.getElementById('hist-coc-used').disabled = true;
          document.getElementById('hist-submit-btn').disabled = true;

          // Show warning message
          const warningHTML = `
            <div class="alert alert-warning">
              <i class="bi bi-exclamation-triangle-fill"></i>
              <strong>Historical Balance Locked:</strong> This employee has already logged overtime.
              Historical balance cannot be added or modified to prevent data inconsistency.
            </div>
          `;
          const formCard = document.querySelector('#content-add-hist .card-body');
          if (formCard && !formCard.querySelector('.alert-warning')) {
            formCard.insertAdjacentHTML('afterbegin', warningHTML);
          }
        } else {
          // Enable form fields
          document.getElementById('hist-month-year').disabled = false;
          document.getElementById('hist-coc-earned').disabled = false;
          document.getElementById('hist-coc-used').disabled = false;
          document.getElementById('hist-submit-btn').disabled = false;

          // Remove warning if exists
          const warning = document.querySelector('#content-add-hist .alert-warning');
          if (warning) warning.remove();
        }

        // Return the result for use in rendering table
        return result.hasLogs;
      } catch (error) {
        console.error('Error checking overtime logs:', error);
        return false;
      }
    }

    function renderEmployeesWithoutHistoricalBalance() {
      const container = document.getElementById('employees-no-hist-list');
      if (!container) return;

      // Get all active employees
      const activeEmployees = employeesData.filter(emp => emp.isActive);

      // Get employees with historical balance (from Firestore)
      const db = getFirestore();
      const q = query(
        collection(db, 'creditBatches'),
        where('source', '==', 'Historical')
      );

      onSnapshot(q, (snapshot) => {
        const employeesWithHist = new Set();
        snapshot.forEach(doc => {
          const batch = doc.data();
          employeesWithHist.add(batch.employeeId);
        });

        const employeesWithoutHist = activeEmployees.filter(emp =>
          !employeesWithHist.has(emp.employeeId)
        );

        if (employeesWithoutHist.length === 0) {
          container.innerHTML = '<span class="text-success"><i class="bi bi-check-circle-fill"></i> All active employees have historical balance migrated!</span>';
        } else {
          container.innerHTML = employeesWithoutHist.map(emp => `
            <span class="badge bg-warning text-dark" style="cursor: pointer;"
                  onclick="selectHistoricalEmployeeFilter('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')"
                  title="Click to add historical balance for this employee">
              ${emp.lastName}, ${emp.firstName} (${emp.employeeId})
            </span>
          `).join('');
        }
      });
    }

    // Click outside to close dropdown
    document.addEventListener('click', function(e) {
      const container = document.querySelector('#hist-employee-filter-search')?.closest('.searchable-select-container');
      if (container && !container.contains(e.target)) {
        hideHistoricalEmployeeFilterDropdown();
      }
    });

    function populateHistoricalEmployeeDropdown() {
      const dropdown = document.getElementById('hist-employee-list');
      if (!dropdown) return;

      const activeEmployees = employeesData.filter(emp => emp.isActive);

      if (activeEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No active employees found</div>';
        return;
      }

      dropdown.innerHTML = activeEmployees.map(emp => `
        <div class="dropdown-item-custom" onclick="selectHistoricalEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
          <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
          <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
        </div>
      `).join('');
    }

    window.filterHistoricalEmployees = function() {
      const searchInput = document.getElementById('hist-employee-search');
      const dropdown = document.getElementById('hist-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-no-results">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectHistoricalEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showHistoricalEmployeeDropdown();
    };

    window.showHistoricalEmployeeDropdown = function() {
      const dropdown = document.getElementById('hist-employee-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideHistoricalEmployeeDropdown = function() {
      const dropdown = document.getElementById('hist-employee-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectHistoricalEmployee = function(employeeId, name) {
      const searchInput = document.getElementById('hist-employee-search');
      const hiddenInput = document.getElementById('hist-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideHistoricalEmployeeDropdown();
    };

    // Enable Date of Issuance when Month & Year is selected
    window.enableDateOfIssuance = function() {
      const monthYear = document.getElementById('hist-month-year').value;
      const dateIssuance = document.getElementById('hist-date-issuance');

      if (monthYear) {
        dateIssuance.disabled = false;

        // Set min and max dates based on the selected month
        const [year, month] = monthYear.split('-');
        const earnedYear = parseInt(year);
        const earnedMonth = parseInt(month);

        // Helper function to format date as YYYY-MM-DD without timezone issues
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };

        // Min: Last day of earned month (e.g., Jan 31, 2024 for January 2024)
        const lastDayOfEarnedMonth = new Date(earnedYear, earnedMonth, 0);
        const minDate = formatDate(lastDayOfEarnedMonth);

        // Max: Last day of the month AFTER the earned month
        // (e.g., Feb 29, 2024 for January 2024, or Jan 31, 2025 for December 2024)
        const lastDayOfNextMonth = new Date(earnedYear, earnedMonth + 1, 0);
        const maxDate = formatDate(lastDayOfNextMonth);

        // Default: 1st day of the month AFTER the earned month
        // (e.g., Feb 1, 2024 for January 2024, or Jan 1, 2025 for December 2024)
        const firstDayOfNextMonth = new Date(earnedYear, earnedMonth, 1);
        const defaultDate = formatDate(firstDayOfNextMonth);

        dateIssuance.min = minDate;
        dateIssuance.max = maxDate;

        // Set default value to the 1st day of the month AFTER the earned month
        dateIssuance.value = defaultDate;
      } else {
        dateIssuance.disabled = true;
        dateIssuance.value = '';
      }

      validateHistoricalFields();
    };

    // Live validation for Historical Balance fields
    window.validateHistoricalFields = function() {
      const earnedInput = document.getElementById('hist-coc-earned');
      const usedInput = document.getElementById('hist-coc-used');
      const earnedValue = parseFloat(earnedInput.value) || 0;
      const usedValue = parseFloat(usedInput.value) || 0;

      // Validate COC Earned (max 40)
      if (earnedValue > 40) {
        earnedInput.classList.add('is-invalid');
        document.getElementById('hist-earned-feedback').textContent = 'Cannot exceed 40 hours per month';
      } else if (earnedValue < 0) {
        earnedInput.classList.add('is-invalid');
        document.getElementById('hist-earned-feedback').textContent = 'Must be a positive number';
      } else {
        earnedInput.classList.remove('is-invalid');
      }

      // Validate COC Used (must be in blocks of 4 or 8, and <= earned)
      if (usedValue > earnedValue) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Cannot exceed COC Earned';
      } else if (usedValue > 0 && usedValue % 4 !== 0) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Must be in blocks of 4 hours (4, 8, 12, 16, etc.)';
      } else if (usedValue < 0) {
        usedInput.classList.add('is-invalid');
        document.getElementById('hist-used-feedback').textContent = 'Must be a positive number';
      } else {
        usedInput.classList.remove('is-invalid');
      }

      // Update auto-calculated fields
      calculateHistoricalRemaining();
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const histContainer = document.querySelector('#hist-employee-dropdown')?.parentElement;
      const histDropdown = document.getElementById('hist-employee-dropdown');

      if (histContainer && histDropdown && !histContainer.contains(event.target)) {
        hideHistoricalEmployeeDropdown();
      }
    });

    async function loadDashboard() {
      const batchesQ = query(collection(db, 'creditBatches'), where('status', '==', 'Active'));
      const logsQ = query(collection(db, 'overtimeLogs'), where('status', '==', 'Uncertified'));

      onSnapshot(batchesQ, (snapshot) => {
        let totalLiability = 0;
        let expiringSoon = 0;
        const today = new Date();
        const thirtyDays = new Date(today);
        thirtyDays.setDate(today.getDate() + 30);

        snapshot.forEach((doc) => {
          const batch = doc.data();
          totalLiability += batch.remainingHours;
          const expiryDate = new Date(batch.expiryDate);
          if (expiryDate <= thirtyDays) {
            expiringSoon += batch.remainingHours;
          }
        });

        document.getElementById('stat-total-liability').textContent = totalLiability.toFixed(2);
        document.getElementById('stat-expiring-soon').textContent = expiringSoon.toFixed(2);
        
        renderAlerts(expiringSoon, snapshot.docs.length);
      });

      onSnapshot(logsQ, (snapshot) => {
        document.getElementById('stat-uncertified').textContent = snapshot.size;
      });

      const empQ = query(collection(db, 'employees'), where('isActive', '==', true));
      onSnapshot(empQ, (snapshot) => {
        document.getElementById('stat-active-employees').textContent = snapshot.size;
      });
    }

    function renderAlerts(expiringSoon, totalBatches) {
      const container = document.getElementById('alerts-container');
      let html = '';

      if (expiringSoon > 0) {
        html += `
          <div class="alert-item warning">
            <i class="bi bi-exclamation-triangle-fill"></i>
            <strong>Expiring Credits:</strong> ${expiringSoon.toFixed(2)} hours will expire in the next 30 days
          </div>
        `;
      }

      if (totalBatches > 50) {
        html += `
          <div class="alert-item info">
            <i class="bi bi-info-circle-fill"></i>
            <strong>Active Batches:</strong> There are ${totalBatches} active credit batches in the system
          </div>
        `;
      }

      if (html === '') {
        html = '<p class="text-muted">No alerts at this time</p>';
      }

      container.innerHTML = html;
    }

    function loadHolidays() {
      const q = query(collection(db, 'holidays'), orderBy('date', 'desc'));
      onSnapshot(q, (snapshot) => {
        const tbody = document.getElementById('holidaysTableBody');
        if (snapshot.empty) {
          tbody.innerHTML = '<tr><td colspan="5" class="text-center">No holidays found</td></tr>';
          return;
        }

        tbody.innerHTML = snapshot.docs.map(doc => {
          const hol = doc.data();
          const date = new Date(hol.date);
          return `
            <tr>
              <td>${date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td>
              <td>${hol.name}</td>
              <td><span class="badge ${hol.type === 'Regular' ? 'bg-danger' : 'bg-warning'}">${hol.type}</span></td>
              <td>${hol.isRecurring ? 'Yes' : 'No'}</td>
              <td>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteHoliday('${doc.id}')">
                  <i class="bi bi-trash"></i>
                </button>
              </td>
            </tr>
          `;
        }).join('');
      });
    }

    function loadConfiguration() {
      console.log('Loading configuration from Firestore...');
      
      const configRef = doc(db, 'configuration', 'accrualRules');
      
      const unsubscribe = onSnapshot(configRef, 
        (docSnap) => {
          console.log('Configuration snapshot received');
          
          if (docSnap.exists()) {
            const config = docSnap.data();
            console.log('Configuration data:', config);
            
            document.getElementById('config-regular').value = config.regularDayMultiplier ?? 1.25;
            document.getElementById('config-restday').value = config.restDayMultiplier ?? 1.30;
            document.getElementById('config-holiday').value = config.holidayMultiplier ?? 2.00;
            document.getElementById('config-monthly-cap').value = config.monthlyAccrualCap ?? 40;
            document.getElementById('config-total-cap').value = config.totalBalanceCap ?? 120;
            document.getElementById('config-expiry-months').value = config.expiryMonths ?? 12;
            
            console.log('Configuration loaded successfully');
          } else {
            console.error('Configuration document does not exist');
          }
        },
        (error) => {
          console.error('Error loading configuration:', error);
        }
      );
      
      unsubscribers.push(unsubscribe);
    }

    function loadLibraries() {
      ['offices', 'positions'].forEach(libType => {
        const q = query(collection(db, 'libraries', libType, 'items'), orderBy('name'));
        onSnapshot(q, (snapshot) => {
          // Store library data for filtering
          librariesData[libType] = [];
          snapshot.forEach((doc) => {
            librariesData[libType].push({ id: doc.id, ...doc.data() });
          });

          // Only render the offices tab initially for better performance
          // Positions tab will be rendered when user switches to it
          if (libType === 'offices') {
            renderLibraryTable(libType);
          }
          populateLibraryDropdowns(libType, snapshot.docs);
        });
      });
    }

    function renderLibraryTable(libType) {
      const container = document.getElementById(`${libType}-list`);
      let items = librariesData[libType];

      // Apply search filter
      if (librarySearchTerms[libType]) {
        items = items.filter(item => {
          const searchLower = librarySearchTerms[libType].toLowerCase();
          return item.name.toLowerCase().includes(searchLower);
        });
      }

      if (items.length === 0) {
        const message = librarySearchTerms[libType] ? 'No items match your search' : 'No items found';
        container.innerHTML = `<tr><td colspan="2" class="text-center text-muted">${message}</td></tr>`;
        return;
      }

      container.innerHTML = items.map(item => {
        return `
          <tr>
            <td>${item.name}</td>
            <td>
              <button class="btn btn-sm btn-outline-primary me-1" onclick="editLibraryItem('${libType}', '${item.id}', '${item.name}')">
                <i class="bi bi-pencil"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger" onclick="deleteLibraryItem('${libType}', '${item.id}', '${item.name}')">
                <i class="bi bi-trash"></i>
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    window.filterLibrary = function(type) {
      const searchInput = document.getElementById(`search-${type}`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      librarySearchTerms[type] = searchInput.value;

      // Show/hide clear button
      if (searchInput.value) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }

      renderLibraryTable(type);
    };

    window.clearLibrarySearch = function(type) {
      const searchInput = document.getElementById(`search-${type}`);
      const clearBtn = document.getElementById(`clear-${type}-search`);

      searchInput.value = '';
      librarySearchTerms[type] = '';
      clearBtn.classList.remove('visible');

      renderLibraryTable(type);
    };

    function populateLibraryDropdowns(libType, docs) {
      const selectId = libType === 'offices' ? 'emp-office' : 'emp-position';
      const select = document.getElementById(selectId);
      select.innerHTML = '<option value="">Select</option>';
      docs.forEach(doc => {
        const item = doc.data();
        select.innerHTML += `<option value="${item.name}">${item.name}</option>`;
      });
    }

    window.loadUncertifiedLogs = async function() {
      const employeeId = document.getElementById('cert-employee').value;
      if (!employeeId) return;

      const q = query(
        collection(db, 'overtimeLogs'),
        where('employeeId', '==', employeeId),
        where('status', '==', 'Uncertified'),
        orderBy('overtimeDate', 'desc')
      );

      onSnapshot(q, (snapshot) => {
        const tbody = document.getElementById('uncertifiedLogsBody');
        if (snapshot.empty) {
          tbody.innerHTML = '<tr><td colspan="6" class="text-center">No uncertified logs</td></tr>';
          return;
        }

        tbody.innerHTML = snapshot.docs.map(doc => {
          const log = doc.data();
          const date = new Date(log.overtimeDate);
          return `
            <tr>
              <td><input type="checkbox" class="log-checkbox" data-logid="${log.logId}" data-hours="${log.earnedHours}" onchange="updateSelectedTotal()"></td>
              <td>${date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td>
              <td>${log.hoursWorked}</td>
              <td><span class="badge bg-secondary">${log.dayType}</span></td>
              <td>${log.multiplier}x</td>
              <td><strong>${log.earnedHours.toFixed(2)}</strong></td>
            </tr>
          `;
        }).join('');
      });
    };

    window.updateSelectedTotal = function() {
      const checkboxes = document.querySelectorAll('.log-checkbox:checked');
      let total = 0;
      checkboxes.forEach(cb => {
        total += parseFloat(cb.dataset.hours);
      });
      document.getElementById('total-selected-hours').textContent = total.toFixed(2);
    };

    window.loadEmployeeLedger = async function() {
      const employeeId = document.getElementById('ledger-employee').value;
      if (!employeeId) return;

      const batchesQ = query(
        collection(db, 'creditBatches'),
        where('employeeId', '==', employeeId),
        where('status', '==', 'Active')
      );

      onSnapshot(batchesQ, (snapshot) => {
        let balance = 0;
        snapshot.forEach(doc => {
          balance += doc.data().remainingHours;
        });
        document.getElementById('ledger-balance').textContent = balance.toFixed(2);
      });

      const ledgerQ = query(
        collection(db, 'ledger'),
        where('employeeId', '==', employeeId),
        orderBy('transactionDate', 'desc')
      );

      onSnapshot(ledgerQ, (snapshot) => {
        const tbody = document.getElementById('ledgerTableBody');
        if (snapshot.empty) {
          tbody.innerHTML = '<tr><td colspan="6" class="text-center">No transactions</td></tr>';
          return;
        }

        tbody.innerHTML = snapshot.docs.map(doc => {
          const ledger = doc.data();
          const date = new Date(ledger.transactionDate);
          const hoursClass = ledger.hoursChange >= 0 ? 'text-success' : 'text-danger';
          return `
            <tr>
              <td>${date.toLocaleDateString('en-US', { timeZone: 'Asia/Manila' })}</td>
              <td><span class="badge bg-info">${ledger.transactionType}</span></td>
              <td>${ledger.referenceId}</td>
              <td class="${hoursClass}"><strong>${ledger.hoursChange >= 0 ? '+' : ''}${ledger.hoursChange.toFixed(2)}</strong></td>
              <td>${ledger.balanceAfter.toFixed(2)}</td>
              <td>${ledger.remarks}</td>
            </tr>
          `;
        }).join('');
      });
    };

    window.showCtoBalance = async function() {
      const employeeId = document.getElementById('cto-employee').value;
      if (!employeeId) {
        document.getElementById('cto-available-balance').textContent = '0.00';
        return;
      }

      const q = query(
        collection(db, 'creditBatches'),
        where('employeeId', '==', employeeId),
        where('status', '==', 'Active')
      );

      onSnapshot(q, (snapshot) => {
        let balance = 0;
        snapshot.forEach(doc => {
          balance += doc.data().remainingHours;
        });
        document.getElementById('cto-available-balance').textContent = balance.toFixed(2);
      });
    };

    window.calculateHistoricalRemaining = function() {
      const earned = parseFloat(document.getElementById('hist-coc-earned').value) || 0;
      const used = parseFloat(document.getElementById('hist-coc-used').value) || 0;
      const dateIssuance = document.getElementById('hist-date-issuance').value;

      const remaining = earned - used;
      document.getElementById('hist-remaining').value = remaining >= 0 ? remaining.toFixed(2) + ' hours' : 'Invalid';

      let validUntil = null;
      if (dateIssuance) {
        const issuanceDate = new Date(dateIssuance);
        validUntil = new Date(issuanceDate);
        validUntil.setFullYear(validUntil.getFullYear() + 1);
        validUntil.setDate(validUntil.getDate() - 1);

        const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'Asia/Manila' };
        document.getElementById('hist-valid-until').value = validUntil.toLocaleDateString('en-US', options);
      } else {
        document.getElementById('hist-valid-until').value = '';
      }

      // Calculate status with expiry check
      let status;
      if (remaining < 0) {
        status = 'Invalid';
      } else if (remaining === 0) {
        status = 'Used';
      } else {
        // Has remaining hours - check if expired
        if (validUntil) {
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const expiry = new Date(validUntil);
          expiry.setHours(0, 0, 0, 0);

          // "Valid Until Nov 11" means valid through entire day of Nov 11
          // Should only expire on Nov 12 onwards
          if (today > expiry) {
            status = 'Expired';
          } else {
            status = 'Active';
          }
        } else {
          status = 'Active';
        }
      }

      document.getElementById('hist-status').value = status;
    };

    document.getElementById('hist-date-issuance').addEventListener('change', calculateHistoricalRemaining);

    // Historical Balances List Management
    let historicalBalancesData = [];

    function loadHistoricalBalances() {
      if (!selectedHistoricalEmployee) {
        const tbody = document.getElementById('historicalBalancesTableBody');
        tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">Select an employee above to view their historical balances</td></tr>`;
        return;
      }

      console.log('Loading historical balances for employee:', selectedHistoricalEmployee);

      // Simpler query - only filter by employeeId, then filter source client-side
      const q = query(
        collection(db, 'creditBatches'),
        where('employeeId', '==', selectedHistoricalEmployee)
      );

      const unsubscribe = onSnapshot(q,
        async (snapshot) => {
          console.log('Snapshot received, docs count:', snapshot.docs.length);
          historicalBalancesData = [];

          for (const docSnapshot of snapshot.docs) {
            const batch = docSnapshot.data();
            console.log('Batch data:', batch);

            // Filter by source on client-side to avoid composite index requirement
            if (batch.source === 'Historical') {
              historicalBalancesData.push({
                id: docSnapshot.id,
                ...batch
              });
            }
          }

          console.log('Filtered historical balances:', historicalBalancesData.length);

          // Sort by monthYear descending (client-side)
          historicalBalancesData.sort((a, b) => {
            if (a.monthYear && b.monthYear) {
              return b.monthYear.localeCompare(a.monthYear);
            }
            return 0;
          });

          renderHistoricalBalancesTable();
        },
        (error) => {
          console.error('Error loading historical balances:', error);
          const tbody = document.getElementById('historicalBalancesTableBody');
          tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">Error loading data: ${error.message}</td></tr>`;
        }
      );

      unsubscribers.push(unsubscribe);
    }

    function renderHistoricalBalancesTable() {
      const tbody = document.getElementById('historicalBalancesTableBody');

      if (historicalBalancesData.length === 0) {
        tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted">No historical balances found for this employee</td></tr>`;
        return;
      }

      tbody.innerHTML = historicalBalancesData.map(batch => {
        // Convert Firestore Timestamps to JavaScript Dates
        const convertDate = (dateField) => {
          if (!dateField) return '-';
          // Handle Firestore Timestamp
          if (dateField.toDate) return dateField.toDate();
          // Handle string dates
          if (typeof dateField === 'string') return new Date(dateField);
          // Already a Date object
          if (dateField instanceof Date) return dateField;
          return new Date(dateField);
        };

        const issuanceDate = convertDate(batch.dateOfIssuance);
        const expiryDate = convertDate(batch.expiryDate);

        const issuedDate = issuanceDate !== '-' ? issuanceDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '-';
        const validUntilDate = expiryDate !== '-' ? expiryDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '-';

        // Format month/year
        const monthYear = batch.monthYear || '-';

        // Dynamic status calculation (checked at runtime)
        let actualStatus = batch.status;
        let statusBadge = '';

        const today = new Date();
        today.setHours(0, 0, 0, 0); // Reset to start of day for comparison

        // Determine status based on remaining hours and expiry date
        if (batch.remainingHours === 0 || batch.remainingHours === undefined) {
          actualStatus = 'Used';
        } else if (batch.remainingHours > 0) {
          // Has remaining hours - check if expired
          if (expiryDate !== '-') {
            const expiry = new Date(expiryDate);
            expiry.setHours(0, 0, 0, 0);

            // If current date is AFTER expiry date (not on the expiry date itself), mark as expired
            // "Valid Until Nov 11" means valid through the entire day of Nov 11
            // Should only expire on Nov 12 onwards
            if (today > expiry) {
              actualStatus = 'Expired';
            } else {
              actualStatus = 'Active';
            }
          } else {
            // No expiry date but has remaining hours - mark as Active
            actualStatus = 'Active';
          }
        }

        // Status badge based on actual (dynamic) status
        if (actualStatus === 'Active') {
          statusBadge = '<span class="badge bg-success">Active</span>';
        } else if (actualStatus === 'Used') {
          statusBadge = '<span class="badge bg-secondary">Used</span>';
        } else if (actualStatus === 'Expired') {
          statusBadge = '<span class="badge bg-danger">Expired</span>';
        }

        return `
          <tr>
            <td>${monthYear}</td>
            <td>${batch.initialHours ? batch.initialHours.toFixed(1) : '0.0'}</td>
            <td>${batch.usedHours ? batch.usedHours.toFixed(1) : '0.0'}</td>
            <td><strong>${batch.remainingHours ? batch.remainingHours.toFixed(1) : '0.0'}</strong></td>
            <td>${issuedDate}</td>
            <td>${validUntilDate}</td>
            <td>${statusBadge}</td>
            <td>
              <button class="btn btn-sm btn-outline-primary me-1" onclick="editHistoricalBalance('${batch.id}')" title="Edit" id="hist-edit-${batch.id}">
                <i class="bi bi-pencil"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger" onclick="deleteHistoricalBalance('${batch.id}')" title="Delete" id="hist-delete-${batch.id}">
                <i class="bi bi-trash"></i>
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    window.deleteHistoricalBalance = async function(batchId) {
      Modal.confirm(
        'Delete Historical Balance',
        'Are you sure you want to delete this historical balance entry? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteHistoricalBalance_SERVER(batchId);
            });

            if (result.success) {
              Modal.success('Success!', 'Historical balance deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting historical balance: ' + error);
          }
        }
      );
    };

    window.editHistoricalBalance = function(batchId) {
      const batch = historicalBalancesData.find(b => b.id === batchId);
      if (!batch) {
        Modal.error('Error', 'Historical balance not found');
        return;
      }

      // Populate form with batch data
      document.getElementById('hist-batch-id').value = batchId;
      document.getElementById('hist-is-edit').value = 'true';
      document.getElementById('hist-month-year').value = batch.monthYear;
      document.getElementById('hist-coc-earned').value = batch.initialHours || batch.earnedHours;
      document.getElementById('hist-coc-used').value = batch.usedHours || 0;

      // Enable and set Date of Issuance
      enableDateOfIssuance();
      const issuanceDate = batch.dateOfIssuance || batch.issueDate;
      if (issuanceDate) {
        const date = new Date(issuanceDate);
        const formatDate = (d) => {
          const year = d.getFullYear();
          const month = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        document.getElementById('hist-date-issuance').value = formatDate(date);
      }

      validateHistoricalFields();

      // Update button text and show Cancel button
      document.getElementById('hist-submit-text').textContent = 'Update';
      document.getElementById('hist-cancel-btn').classList.remove('d-none');

      // Switch to Add tab
      document.getElementById('tab-add-hist').click();

      // Scroll to form
      document.getElementById('content-add-hist').scrollIntoView({ behavior: 'smooth' });
    };

    window.cancelEditHistoricalBalance = function() {
      resetHistoricalForm();
      // Switch to list tab
      document.getElementById('tab-list-hist').click();
    };

    window.resetHistoricalForm = function() {
      const form = document.getElementById('historicalForm');
      const employeeName = document.getElementById('hist-employee-name').value;
      const employeeId = document.getElementById('hist-employee').value;

      form.reset();
      form.classList.remove('was-validated');

      // Clear hidden fields
      document.getElementById('hist-batch-id').value = '';
      document.getElementById('hist-is-edit').value = 'false';

      // Restore employee info
      document.getElementById('hist-employee-name').value = employeeName;
      document.getElementById('hist-employee').value = employeeId;

      // Reset date field
      document.getElementById('hist-date-issuance').disabled = true;
      document.getElementById('hist-date-issuance').value = '';

      // Reset validation
      document.getElementById('hist-coc-earned').classList.remove('is-invalid');
      document.getElementById('hist-coc-used').classList.remove('is-invalid');

      // Reset calculated fields
      calculateHistoricalRemaining();

      // Reset button text and hide Cancel button
      document.getElementById('hist-submit-text').textContent = 'Migrate';
      document.getElementById('hist-cancel-btn').classList.add('d-none');
    };

    window.generateCertificate = async function() {
      const employeeId = document.getElementById('cert-employee').value;
      const checkboxes = document.querySelectorAll('.log-checkbox:checked');
      
      if (!employeeId || checkboxes.length === 0) {
        Modal.error('Validation Error', 'Please select an employee and at least one overtime log');
        return;
      }

      const selectedLogIds = Array.from(checkboxes).map(cb => cb.dataset.logid);

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .generateCertificate_SERVER({ employeeId, selectedLogIds });
        });

        if (result.success) {
          const message = `Certificate ID: ${result.certificateId}\nTotal Hours: ${result.totalEarnedHours.toFixed(2)}`;
          Modal.success('Certificate Generated!', message);
          document.getElementById('cert-employee').value = '';
          document.getElementById('uncertifiedLogsBody').innerHTML = '<tr><td colspan="6" class="text-center">Select an employee</td></tr>';
          document.getElementById('total-selected-hours').textContent = '0.00';
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error generating certificate: ' + error);
      }
    };

    // ========== LOG OVERTIME FEATURE ==========

    // Global state for overtime entries
    let overtimeEntries = [];
    let overtimeRowCounter = 0;
    let overtimeMonthlyTotal = 0;
    let overtimeTotalBalance = 0;

    // Initialize year dropdown (current year and previous 2 years)
    (function initializeOvertimeYearDropdown() {
      const yearSelect = document.getElementById('ot-year');
      const currentYear = new Date().getFullYear();
      for (let i = 0; i < 3; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (i === 0) option.selected = true;
        yearSelect.appendChild(option);
      }
    })();

    // Filter overtime employees
    window.filterOvertimeEmployees = function() {
      const searchInput = document.getElementById('ot-employee-search');
      const dropdown = document.getElementById('ot-employee-list');
      const searchTerm = searchInput.value.toLowerCase().trim();

      const activeEmployees = employeesData.filter(emp => emp.isActive);
      let filteredEmployees = activeEmployees;

      if (searchTerm) {
        filteredEmployees = activeEmployees.filter(emp => {
          const fullName = `${emp.firstName} ${emp.lastName}`.toLowerCase();
          const reverseName = `${emp.lastName} ${emp.firstName}`.toLowerCase();
          const employeeId = emp.employeeId.toLowerCase();
          return fullName.includes(searchTerm) ||
                 reverseName.includes(searchTerm) ||
                 employeeId.includes(searchTerm);
        });
      }

      if (filteredEmployees.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-item-custom text-muted">No employees found</div>';
      } else {
        dropdown.innerHTML = filteredEmployees.map(emp => `
          <div class="dropdown-item-custom" onclick="selectOvertimeEmployee('${emp.employeeId}', '${emp.lastName}, ${emp.firstName}')">
            <span class="employee-name">${emp.lastName}, ${emp.firstName}</span>
            <span class="employee-details">${emp.employeeId} • ${emp.office} • ${emp.position}</span>
          </div>
        `).join('');
      }

      showOvertimeEmployeeDropdown();
    };

    window.showOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      if (dropdown) dropdown.style.display = 'block';
    };

    window.hideOvertimeEmployeeDropdown = function() {
      const dropdown = document.getElementById('ot-employee-dropdown');
      if (dropdown) dropdown.style.display = 'none';
    };

    window.selectOvertimeEmployee = function(employeeId, name) {
      const searchInput = document.getElementById('ot-employee-search');
      const hiddenInput = document.getElementById('ot-employee');

      searchInput.value = `${name} (${employeeId})`;
      hiddenInput.value = employeeId;

      hideOvertimeEmployeeDropdown();
      updateOvertimeMonthOptions(); // Update month options based on employee/year
    };

    // Store original month names
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    const historicalBalanceCache = new Map();

    function resetMonthOption(option) {
      if (option.value === '') return;
      const monthValue = parseInt(option.value);
      option.disabled = false;
      option.textContent = monthNames[monthValue];
      option.classList.remove('text-muted');
      delete option.dataset.state;
    }

    function applyFutureStates(monthSelect, selectedYear) {
      const today = new Date();
      const currentYear = today.getFullYear();
      const currentMonth = today.getMonth();

      Array.from(monthSelect.options).forEach(option => {
        if (option.value === '') return;
        const monthValue = parseInt(option.value);
        const monthName = monthNames[monthValue];
        const isFuture = (selectedYear > currentYear) || (selectedYear === currentYear && monthValue > currentMonth);

        if (isFuture) {
          option.disabled = true;
          option.textContent = `${monthName} (Future)`;
          option.classList.add('text-muted');
          option.dataset.state = 'future';
        } else {
          option.dataset.state = 'available';
        }
      });
    }

    function applyHistoricalStates(monthSelect, historicalMonths) {
      const historicalSet = new Set(historicalMonths);
      Array.from(monthSelect.options).forEach(option => {
        if (option.value === '' || option.dataset.state === 'future') return;
        const monthValue = parseInt(option.value);
        if (historicalSet.has(monthValue)) {
          const monthName = monthNames[monthValue];
          option.disabled = true;
          option.textContent = `${monthName} (Historical Balance)`;
          option.classList.add('text-muted');
          option.dataset.state = 'historical';
        }
      });
    }

    function ensureValidMonthSelection(monthSelect) {
      if (!monthSelect) return;
      const selectedValue = monthSelect.value;
      if (selectedValue === '') return;
      const selectedOption = monthSelect.options[monthSelect.selectedIndex];
      if (!selectedOption || selectedOption.disabled) {
        monthSelect.value = '';
      }
    }

    // Update month options to disable future months and months with historical balance
    window.updateOvertimeMonthOptions = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const yearInput = document.getElementById('ot-year').value;
      const monthSelect = document.getElementById('ot-month');

      if (!monthSelect) {
        return;
      }

      Array.from(monthSelect.options).forEach(resetMonthOption);

      if (!employeeId || !yearInput) {
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
        return;
      }

      const year = parseInt(yearInput);
      applyFutureStates(monthSelect, year);
      ensureValidMonthSelection(monthSelect);

      const cacheKey = `${employeeId}-${year}`;
      const cachedMonths = historicalBalanceCache.get(cacheKey);
      if (cachedMonths) {
        applyHistoricalStates(monthSelect, cachedMonths);
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
        return;
      }

      try {
        const histResult = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getHistoricalBalanceMonths_SERVER(employeeId, year);
        });

        const historicalMonths = Array.isArray(histResult.months) ? histResult.months : [];
        historicalBalanceCache.set(cacheKey, historicalMonths);
        applyHistoricalStates(monthSelect, historicalMonths);
      } catch (error) {
        console.error('Error updating month options:', error);
      } finally {
        ensureValidMonthSelection(monthSelect);
        updateOvertimeContext();
      }
    };

    // Update overtime context (when employee/month/year changes)
    window.updateOvertimeContext = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const month = document.getElementById('ot-month').value;
      const year = document.getElementById('ot-year').value;

      const alertContainer = document.getElementById('ot-alert-container');
      const loadingContainer = document.getElementById('ot-entry-loading');
      const tableWrapper = document.getElementById('ot-entry-table-wrapper');
      const entrySection = document.getElementById('ot-entry-section');
      const totalSection = document.getElementById('ot-total-section');
      const submitSection = document.getElementById('ot-submit-section');

      const hideEntryContent = () => {
        if (loadingContainer) loadingContainer.classList.remove('active');
        if (tableWrapper) tableWrapper.classList.add('d-none');
      };

      const toggleEntryLoading = (isLoading) => {
        if (!loadingContainer || !tableWrapper) return;
        const addDayBtn = document.getElementById('ot-add-day-btn');
        if (isLoading) {
          loadingContainer.classList.add('active');
          tableWrapper.classList.add('d-none');
          if (addDayBtn) addDayBtn.disabled = true;
        } else {
          loadingContainer.classList.remove('active');
          tableWrapper.classList.remove('d-none');
          if (addDayBtn) addDayBtn.disabled = false;
        }
      };

      alertContainer.innerHTML = '';

      if (!employeeId || month === '' || !year) {
        // Hide all sections if incomplete
        document.getElementById('ot-progress-section').style.display = 'none';
        if (entrySection) entrySection.style.display = 'none';
        if (totalSection) totalSection.style.display = 'none';
        if (submitSection) submitSection.style.display = 'none';
        hideEntryContent();
        return;
      }

      // Show progress section and loading state
      document.getElementById('ot-progress-section').style.display = 'flex';
      if (entrySection) entrySection.style.display = 'block';
      if (totalSection) totalSection.style.display = 'none';
      if (submitSection) submitSection.style.display = 'none';
      toggleEntryLoading(true);

      try {
        // Check for certificate or historical balance blocking
        const blockCheck = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .checkOvertimeBlocks_SERVER(employeeId, parseInt(month), parseInt(year));
        });

        if (!blockCheck.success) {
          alertContainer.innerHTML = `
            <div class="alert alert-danger">
              <i class="bi bi-exclamation-triangle-fill"></i>
              <strong>Blocked:</strong> ${blockCheck.error}
            </div>
          `;
          if (entrySection) entrySection.style.display = 'none';
          if (totalSection) totalSection.style.display = 'none';
          if (submitSection) submitSection.style.display = 'none';
          hideEntryContent();
          return;
        }

        // Load existing uncertified logs for this month
        const existingLogs = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getUncertifiedOvertimeForMonth_SERVER(employeeId, parseInt(month), parseInt(year));
        });

        // Calculate monthly total
        overtimeMonthlyTotal = existingLogs.reduce((sum, log) => sum + Number(log.earnedHours || 0), 0);

        // Get total balance (Active + Uncertified)
        const balanceData = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getTotalBalance_SERVER(employeeId);
        });

        if (!balanceData.success) {
          throw new Error(balanceData.error || 'Unable to retrieve total balance');
        }

        const activeBalance = Number(balanceData.active || 0);
        const uncertifiedBalance = Number(balanceData.uncertified || 0);
        overtimeTotalBalance = activeBalance + uncertifiedBalance;

        // Update progress bars
        updateOvertimeProgress();

        // Show entry section
        toggleEntryLoading(false);
        if (entrySection) entrySection.style.display = 'block';
        if (totalSection) totalSection.style.display = 'block';
        if (submitSection) submitSection.style.display = 'block';

        // Clear existing entries
        overtimeEntries = [];
        document.getElementById('ot-entries-tbody').innerHTML = '';
        calculateOvertimeGrandTotal();

      } catch (error) {
        console.error('Error updating overtime context:', error);
        Modal.error('Error', 'Failed to load overtime context: ' + error);
        hideEntryContent();
        if (entrySection) entrySection.style.display = 'none';
        if (totalSection) totalSection.style.display = 'none';
        if (submitSection) submitSection.style.display = 'none';
      }
    };

    // Update progress bars
    function updateOvertimeProgress() {
      // Monthly accrual (current + entries)
      const entriesTotal = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);
      const monthlyTotal = overtimeMonthlyTotal + entriesTotal;
      const monthlyPercent = Math.min((monthlyTotal / 40) * 100, 100);

      document.getElementById('ot-monthly-hours').textContent = monthlyTotal.toFixed(1);
      const monthlyBar = document.getElementById('ot-monthly-progress');
      monthlyBar.style.width = monthlyPercent + '%';
      monthlyBar.className = monthlyPercent >= 100 ? 'progress-bar bg-danger' :
                             monthlyPercent >= 80 ? 'progress-bar bg-warning' :
                             'progress-bar bg-success';

      // Total balance - ensure overtimeTotalBalance is defined
      const currentOvertimeBalance = (typeof overtimeTotalBalance !== 'undefined') ? overtimeTotalBalance : 0;
      const totalBalance = currentOvertimeBalance + entriesTotal;
      const totalPercent = Math.min((totalBalance / 120) * 100, 100);

      document.getElementById('ot-total-hours').textContent = totalBalance.toFixed(1);
      const totalBar = document.getElementById('ot-total-progress');
      totalBar.style.width = totalPercent + '%';
      totalBar.className = totalPercent >= 100 ? 'progress-bar bg-danger' :
                           totalPercent >= 80 ? 'progress-bar bg-warning' :
                           'progress-bar bg-success';
    }

    // Add overtime day row
    window.addOvertimeDay = function() {
      const rowId = ++overtimeRowCounter;
      const tbody = document.getElementById('ot-entries-tbody');

      const row = document.createElement('tr');
      row.id = `ot-row-${rowId}`;
      row.innerHTML = `
        <td>
          <input type="number" class="form-control form-control-sm" id="ot-date-${rowId}" min="1" max="31"
                 placeholder="Day" inputmode="numeric" onchange="onOvertimeDateChange(${rowId})" required>
        </td>
        <td>
          <span class="badge bg-secondary" id="ot-daytype-${rowId}">-</span>
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-am-in-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-am-out-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-pm-in-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="time" class="form-control form-control-sm" id="ot-pm-out-${rowId}"
                 oninput="calculateOvertimeRow(${rowId})" onchange="calculateOvertimeRow(${rowId})">
        </td>
        <td>
          <input type="text" class="form-control form-control-sm" id="ot-hours-worked-${rowId}"
                 readonly style="background-color: #f8f9fa;">
        </td>
        <td>
          <input type="text" class="form-control form-control-sm" id="ot-coc-earned-${rowId}"
                 readonly style="background-color: #f8f9fa;">
        </td>
        <td>
          <button type="button" class="btn btn-sm btn-danger" onclick="removeOvertimeDay(${rowId})" title="Remove">
            <i class="bi bi-trash"></i>
          </button>
        </td>
      `;

      tbody.appendChild(row);

      // Add to entries array
      overtimeEntries.push({
        rowId: rowId,
        date: null,
        displayDate: null,
        dayType: null,
        amIn: null,
        amOut: null,
        pmIn: null,
        pmOut: null,
        hoursWorked: 0,
        cocEarned: 0
      });
    };

    // Remove overtime day row
    window.removeOvertimeDay = function(rowId) {
      const row = document.getElementById(`ot-row-${rowId}`);
      if (row) row.remove();

      // Remove from entries array
      overtimeEntries = overtimeEntries.filter(entry => entry.rowId !== rowId);

      calculateOvertimeGrandTotal();
      updateOvertimeProgress();
    };

    function formatISODateForDisplay(isoDate) {
      if (!isoDate) return '';
      const parts = isoDate.split('-').map(Number);
      if (parts.length !== 3) return isoDate;
      const [year, month, day] = parts;
      const date = new Date(year, month - 1, day);
      if (Number.isNaN(date.getTime())) return isoDate;
      return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    }

    function resetOvertimeEntryDate(entry, rowId) {
      if (!entry) return;

      entry.date = null;
      entry.displayDate = null;
      entry.dayType = null;
      entry.isHoliday = false;
      entry.holidayName = '';
      entry.hoursWorked = 0;
      entry.cocEarned = 0;
      entry.error = null;

      const badge = document.getElementById(`ot-daytype-${rowId}`);
      if (badge) {
        badge.textContent = '-';
        badge.className = 'badge bg-secondary';
      }

      const hoursField = document.getElementById(`ot-hours-worked-${rowId}`);
      if (hoursField) hoursField.value = '';
      const cocField = document.getElementById(`ot-coc-earned-${rowId}`);
      if (cocField) cocField.value = '';
    }

    function formatOvertimeEntryLabel(entry) {
      if (!entry) return 'selected day';
      if (entry.displayDate) return entry.displayDate;
      if (entry.date) return formatISODateForDisplay(entry.date);
      return 'selected day';
    }

    // On date change - auto-detect day type
    window.onOvertimeDateChange = async function(rowId) {
      const dateInput = document.getElementById(`ot-date-${rowId}`);
      const entry = overtimeEntries.find(e => e.rowId === rowId);
      if (!dateInput || !entry) return;

      const rawValue = dateInput.value;

      if (!rawValue) {
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const day = parseInt(rawValue, 10);
      if (Number.isNaN(day)) {
        Modal.error('Invalid Day', 'Please enter a valid day number (1-31).');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const monthValue = document.getElementById('ot-month').value;
      const yearValue = document.getElementById('ot-year').value;

      if (monthValue === '' || !yearValue) {
        Modal.error('Incomplete Selection', 'Please select the overtime month and year first.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const selectedMonth = parseInt(monthValue, 10);
      const selectedYear = parseInt(yearValue, 10);

      if (Number.isNaN(selectedMonth) || Number.isNaN(selectedYear)) {
        Modal.error('Invalid Selection', 'Selected month or year is invalid.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const candidateDate = new Date(selectedYear, selectedMonth, day);
      if (candidateDate.getMonth() !== selectedMonth || candidateDate.getFullYear() !== selectedYear || candidateDate.getDate() !== day) {
        Modal.error('Invalid Day', 'The entered day is not valid for the selected month.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const isoDate = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const comparisonDate = new Date(candidateDate);
      comparisonDate.setHours(0, 0, 0, 0);
      if (comparisonDate > today) {
        Modal.error('Invalid Date', 'Future dates are not allowed.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      const duplicateCount = overtimeEntries.filter(item => item.rowId !== rowId && item.date === isoDate).length;
      if (duplicateCount > 0) {
        Modal.error('Duplicate Date', 'This day has already been entered for the selected month.');
        dateInput.value = '';
        resetOvertimeEntryDate(entry, rowId);
        calculateOvertimeGrandTotal();
        updateOvertimeProgress();
        return;
      }

      entry.date = isoDate;
      entry.displayDate = formatISODateForDisplay(isoDate);

      let resolvedDayType = 'weekday';
      let isHoliday = false;
      let holidayName = '';

      const badge = document.getElementById(`ot-daytype-${rowId}`);

      try {
        const dayTypeResult = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getDayType_SERVER(isoDate);
        });

        if (badge) {
          if (dayTypeResult.isHoliday) {
            badge.textContent = `Holiday (${dayTypeResult.holidayName})`;
            badge.className = 'badge bg-danger';
          } else if (dayTypeResult.isWeekend) {
            badge.textContent = 'Weekend';
            badge.className = 'badge bg-warning text-dark';
          } else {
            badge.textContent = 'Weekday';
            badge.className = 'badge bg-primary';
          }
        }

        if (dayTypeResult.isHoliday) {
          resolvedDayType = 'holiday';
          isHoliday = true;
          holidayName = dayTypeResult.holidayName || '';
        } else if (dayTypeResult.isWeekend) {
          resolvedDayType = 'weekend';
        }
      } catch (error) {
        console.error('Error detecting day type:', error);
        if (badge) {
          badge.textContent = 'Weekday';
          badge.className = 'badge bg-primary';
        }
      }

      entry.dayType = resolvedDayType;
      entry.isHoliday = isHoliday;
      entry.holidayName = holidayName;

      calculateOvertimeRow(rowId);
    };

    // Calculate overtime for a single row
    window.calculateOvertimeRow = function(rowId) {
      const entry = overtimeEntries.find(e => e.rowId === rowId);
      if (!entry || !entry.date) return;

      const amInEl = document.getElementById(`ot-am-in-${rowId}`);
      const amOutEl = document.getElementById(`ot-am-out-${rowId}`);
      const pmInEl = document.getElementById(`ot-pm-in-${rowId}`);
      const pmOutEl = document.getElementById(`ot-pm-out-${rowId}`);

      const amIn = amInEl.value;
      const amOut = amOutEl.value;
      const pmIn = pmInEl.value;
      const pmOut = pmOutEl.value;

      // Clear all validation states first
      [amInEl, amOutEl, pmInEl, pmOutEl].forEach(el => {
        el.classList.remove('is-invalid');
        el.classList.remove('border-danger');
      });

      // Update entry
      entry.amIn = amIn;
      entry.amOut = amOut;
      entry.pmIn = pmIn;
      entry.pmOut = pmOut;

      // Validate time inputs
      let isValid = true;
      let errorMsg = '';
      const invalidFields = [];

      // AM validation
      if (amIn && amOut) {
        const amInTime = parseTime(amIn);
        const amOutTime = parseTime(amOut);

        // AM In: Must be 5:00 AM - 12:59 PM
        if (amInTime < parseTime('05:00') || amInTime >= parseTime('13:00')) {
          errorMsg = 'AM In must be between 5:00 AM and 12:59 PM';
          isValid = false;
          invalidFields.push(amInEl);
        }

        // AM Out: Must be 8:00 AM - 12:59 PM
        if (amOutTime < parseTime('08:00') || amOutTime >= parseTime('13:00')) {
          errorMsg = errorMsg || 'AM Out must be between 8:00 AM and 12:59 PM';
          isValid = false;
          invalidFields.push(amOutEl);
        }

        // AM Out must be after AM In
        if (isValid && amOutTime <= amInTime) {
          errorMsg = 'AM Out must be after AM In';
          isValid = false;
          invalidFields.push(amInEl, amOutEl);
        }
      } else if (amIn || amOut) {
        errorMsg = 'Both AM In and AM Out must be filled';
        isValid = false;
        if (amIn && !amOut) invalidFields.push(amOutEl);
        if (!amIn && amOut) invalidFields.push(amInEl);
      }

      // PM validation
      if (pmIn && pmOut) {
        const pmInTime = parseTime(pmIn);
        const pmOutTime = parseTime(pmOut);

        // PM In: Must be 12:00 PM - 11:59 PM
        if (pmInTime < parseTime('12:00')) {
          errorMsg = errorMsg || 'PM In must be 12:00 PM or later';
          isValid = false;
          invalidFields.push(pmInEl);
        }

        // PM Out: Must be 12:00 PM - 11:59 PM
        if (pmOutTime < parseTime('12:00')) {
          errorMsg = errorMsg || 'PM Out must be 12:00 PM or later';
          isValid = false;
          invalidFields.push(pmOutEl);
        }

        // PM Out must be after PM In
        if (isValid && pmOutTime <= pmInTime) {
          errorMsg = errorMsg || 'PM Out must be after PM In';
          isValid = false;
          invalidFields.push(pmInEl, pmOutEl);
        }
      } else if (pmIn || pmOut) {
        errorMsg = errorMsg || 'Both PM In and PM Out must be filled';
        isValid = false;
        if (pmIn && !pmOut) invalidFields.push(pmOutEl);
        if (!pmIn && pmOut) invalidFields.push(pmInEl);
      }

      // Noon break validation
      if (amOut && pmIn && isValid) {
        if (parseTime(pmIn) <= parseTime(amOut)) {
          errorMsg = 'PM In must be after AM Out (noon break required)';
          isValid = false;
          invalidFields.push(amOutEl, pmInEl);
        }
      }

      // Apply visual feedback to invalid fields
      invalidFields.forEach(el => {
        el.classList.add('is-invalid');
        el.classList.add('border-danger');
      });

      if (!isValid) {
        entry.hoursWorked = 0;
        entry.cocEarned = 0;
        entry.error = errorMsg;

        // Show error tooltip or console message
        if (invalidFields.length > 0) {
          invalidFields[0].title = errorMsg;
        }
      } else {
        entry.error = null;

        // Calculate hours worked and COC earned
        const result = calculateOvertimeHours(entry.dayType || 'weekday', amIn, amOut, pmIn, pmOut);
        entry.hoursWorked = result.hoursWorked;
        entry.cocEarned = result.cocEarned;
      }

      // Update display
      document.getElementById(`ot-hours-worked-${rowId}`).value = entry.hoursWorked.toFixed(1);
      document.getElementById(`ot-coc-earned-${rowId}`).value = entry.cocEarned.toFixed(1);

      calculateOvertimeGrandTotal();
      updateOvertimeProgress();
    };

    // Helper: Parse time string to minutes
    function parseTime(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    }

    // Helper: Calculate overlap between two time ranges
    function calculateOverlap(start1, end1, start2, end2) {
      const overlapStart = Math.max(start1, start2);
      const overlapEnd = Math.min(end1, end2);
      return Math.max(0, overlapEnd - overlapStart);
    }

    // Calculate overtime hours based on time windows
    function calculateOvertimeHours(dayType, amIn, amOut, pmIn, pmOut) {
      let hoursWorked = 0;
      let cocEarned = 0;

      if (dayType === 'weekday') {
        // Weekday: Only PM window 5:00 PM - 7:00 PM (17:00-19:00), rate 1.0x, max 2 hours
        if (pmIn && pmOut) {
          const pmInTime = parseTime(pmIn);
          const pmOutTime = parseTime(pmOut);
          const windowStart = parseTime('17:00');
          const windowEnd = parseTime('19:00');

          const overlap = calculateOverlap(pmInTime, pmOutTime, windowStart, windowEnd);
          const hours = Math.min(overlap / 60, 2.0); // Max 2 hours
          hoursWorked += hours;
          cocEarned += hours * 1.0; // 1.0x rate
        }
      } else {
        // Weekend/Holiday: AM window 8:00 AM - 12:00 PM, PM window 1:00 PM - 5:00 PM (13:00-17:00), rate 1.5x

        // AM window
        if (amIn && amOut) {
          const amInTime = parseTime(amIn);
          const amOutTime = parseTime(amOut);
          const windowStart = parseTime('08:00');
          const windowEnd = parseTime('12:00');

          const overlap = calculateOverlap(amInTime, amOutTime, windowStart, windowEnd);
          const hours = overlap / 60;
          hoursWorked += hours;
          cocEarned += hours * 1.5; // 1.5x rate
        }

        // PM window
        if (pmIn && pmOut) {
          const pmInTime = parseTime(pmIn);
          const pmOutTime = parseTime(pmOut);
          const windowStart = parseTime('13:00');
          const windowEnd = parseTime('17:00');

          const overlap = calculateOverlap(pmInTime, pmOutTime, windowStart, windowEnd);
          const hours = overlap / 60;
          hoursWorked += hours;
          cocEarned += hours * 1.5; // 1.5x rate
        }
      }

      return { hoursWorked, cocEarned };
    }

    // Calculate grand total
    function calculateOvertimeGrandTotal() {
      const totalHoursWorked = overtimeEntries.reduce((sum, entry) => sum + Number(entry.hoursWorked || 0), 0);
      const totalCocEarned = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);

      document.getElementById('ot-grand-hours-worked').textContent = totalHoursWorked.toFixed(1);
      document.getElementById('ot-grand-coc-earned').textContent = totalCocEarned.toFixed(1);
    }

    // Submit overtime form
    window.submitOvertimeForm = async function() {
      const employeeId = document.getElementById('ot-employee').value;
      const month = parseInt(document.getElementById('ot-month').value);
      const year = parseInt(document.getElementById('ot-year').value);

      // Validation
      if (!employeeId || month === '' || !year) {
        Modal.error('Validation Error', 'Please select employee, month, and year.');
        return;
      }

      if (overtimeEntries.length === 0) {
        Modal.error('Validation Error', 'Please add at least one overtime entry.');
        return;
      }

      // Validate all entries have required data
      for (const entry of overtimeEntries) {
        if (!entry.date) {
          Modal.error('Validation Error', 'All entries must have a date.');
          return;
        }

        const entryLabel = formatOvertimeEntryLabel(entry);

        if (!entry.amIn && !entry.amOut && !entry.pmIn && !entry.pmOut) {
          Modal.error('Validation Error', `Entry for ${entryLabel} has no time inputs.`);
          return;
        }
        if (entry.error) {
          Modal.error('Validation Error', `Entry for ${entryLabel}: ${entry.error}`);
          return;
        }
      }

      // Check monthly cap
      const totalCocEarned = overtimeEntries.reduce((sum, entry) => sum + Number(entry.cocEarned || 0), 0);
      const newMonthlyTotal = overtimeMonthlyTotal + totalCocEarned;

      if (newMonthlyTotal > 40) {
        Modal.error('Monthly Cap Exceeded',
          `Total would be ${newMonthlyTotal.toFixed(1)} hours, exceeding the 40-hour monthly accrual cap.`);
        return;
      }

      // Check total balance cap
      const currentOvertimeBalance = (typeof overtimeTotalBalance !== 'undefined') ? overtimeTotalBalance : 0;
      const newTotalBalance = currentOvertimeBalance + totalCocEarned;
      if (newTotalBalance > 120) {
        Modal.error('Total Balance Cap Exceeded',
          `Total balance would be ${newTotalBalance.toFixed(1)} hours, exceeding the 120-hour cap.`);
        return;
      }

      // Show spinner
      const spinner = document.getElementById('ot-submit-spinner');
      spinner.classList.remove('d-none');

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .logOvertimeBatch_SERVER({
              employeeId: employeeId,
              month: month,
              year: year,
              entries: overtimeEntries.map(entry => ({
                date: entry.date,
                dayType: entry.dayType,
                isHoliday: entry.isHoliday,
                holidayName: entry.holidayName,
                amIn: entry.amIn,
                amOut: entry.amOut,
                pmIn: entry.pmIn,
                pmOut: entry.pmOut,
                hoursWorked: entry.hoursWorked,
                cocEarned: entry.cocEarned
              }))
            });
        });

        if (result.success) {
          const message = `
            <div style="text-align: center;">
              <h4 class="text-success mb-3">${result.count} overtime log(s) created</h4>
              <div class="mb-3">
                <h5 class="text-primary mb-0">${result.totalCocEarned.toFixed(1)} hours</h5>
                <small class="text-muted">Total COC Earned (Uncertified)</small>
              </div>
              <p class="text-muted mb-0">Generate a certificate to activate these credits.</p>
            </div>
          `;
          Modal.success('Overtime Logged Successfully!', message);

          // Reset form
          overtimeEntries = [];
          document.getElementById('ot-entries-tbody').innerHTML = '';
          calculateOvertimeGrandTotal();
          updateOvertimeContext();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Failed to log overtime: ' + error);
      } finally {
        spinner.classList.add('d-none');
      }
    };

    // Click outside to close dropdown
    document.addEventListener('click', function(e) {
      const otContainer = document.querySelector('#ot-employee-search')?.closest('.searchable-select-container');
      if (otContainer && !otContainer.contains(e.target)) {
        hideOvertimeEmployeeDropdown();
      }
    });

    document.getElementById('ctoForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const data = {
        employeeId: document.getElementById('cto-employee').value,
        ctoDate: document.getElementById('cto-date').value,
        hoursUsed: document.getElementById('cto-hours').value,
        remarks: document.getElementById('cto-remarks').value
      };

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .logCto_SERVER(data);
        });

        if (result.success) {
          const message = `Hours Used: ${result.hoursUsed}\nNew Balance: ${result.newBalance.toFixed(2)} hours`;
          Modal.success('CTO Logged!', message);
          e.target.reset();
          document.getElementById('cto-available-balance').textContent = '0.00';
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error logging CTO: ' + error);
      }
    });

    document.getElementById('historicalForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const form = e.target;
      const submitBtn = document.getElementById('hist-submit-btn');
      const btnText = submitBtn.querySelector('.btn-text');
      const spinner = submitBtn.querySelector('.spinner-border');

      form.classList.add('was-validated');

      if (!form.checkValidity()) {
        return;
      }

      const cocEarned = parseFloat(document.getElementById('hist-coc-earned').value);
      const cocUsed = parseFloat(document.getElementById('hist-coc-used').value) || 0;

      // Additional validation
      if (cocUsed > cocEarned) {
        Modal.error('Validation Error', 'COC Used cannot exceed COC Earned');
        return;
      }

      if (cocUsed > 0 && cocUsed % 4 !== 0) {
        Modal.error('Validation Error', 'COC Used must be in blocks of 4 hours (4, 8, 12, 16, etc.)');
        return;
      }

      const isEdit = document.getElementById('hist-is-edit').value === 'true';
      const batchId = document.getElementById('hist-batch-id').value;

      const data = {
        employeeId: document.getElementById('hist-employee').value,
        monthYear: document.getElementById('hist-month-year').value,
        cocEarned: cocEarned,
        cocUsed: cocUsed,
        dateOfIssuance: document.getElementById('hist-date-issuance').value
      };

      if (isEdit) {
        data.batchId = batchId;
      }

      // Show spinner
      submitBtn.disabled = true;
      btnText.classList.add('d-none');
      spinner.classList.remove('d-none');

      try {
        const serverFunction = isEdit ? 'updateHistoricalBalance_SERVER' : 'migrateHistoricalBalance_SERVER';
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [serverFunction](data);
        });

        if (result.success) {
          const message = `
            <div style="text-align: center;">
              <div class="mb-3">
                <h4 class="text-primary mb-0">${result.remainingHours} hours</h4>
                <small class="text-muted">Remaining Balance</small>
              </div>
              <div class="d-flex justify-content-around">
                <div>
                  <strong>Valid Until:</strong><br>
                  ${result.validUntil}
                </div>
                <div>
                  <strong>Status:</strong><br>
                  <span class="badge bg-success">${result.status}</span>
                </div>
              </div>
            </div>
          `;
          Modal.success(isEdit ? 'Historical Balance Updated!' : 'Historical Balance Migrated!', message);

          // Reset form using reset function
          resetHistoricalForm();

          // The list will auto-update via onSnapshot listener
        } else {
          Modal.error('Migration Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error migrating balance: ' + error);
      } finally {
        // Hide spinner
        submitBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    });

    document.getElementById('configForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const data = {
        regularDayMultiplier: parseFloat(document.getElementById('config-regular').value),
        restDayMultiplier: parseFloat(document.getElementById('config-restday').value),
        holidayMultiplier: parseFloat(document.getElementById('config-holiday').value),
        monthlyAccrualCap: parseInt(document.getElementById('config-monthly-cap').value),
        totalBalanceCap: parseInt(document.getElementById('config-total-cap').value),
        expiryMonths: parseInt(document.getElementById('config-expiry-months').value)
      };

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .saveConfiguration_SERVER(data);
        });

        if (result.success) {
          Modal.success('Success!', 'Configuration saved successfully!');
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving configuration: ' + error);
      }
    });

    window.resetEmployeeForm = function() {
      const form = document.getElementById('employeeForm');
      form.reset();
      form.classList.remove('was-validated');
      document.querySelectorAll('.form-control, .form-select').forEach(el => {
        el.classList.remove('is-invalid');
      });
      document.getElementById('emp-id-hidden').value = '';
      document.getElementById('emp-id-display').style.display = 'none';
      document.getElementById('employeeModalTitle').textContent = 'Add Employee';
      document.getElementById('emp-status').value = 'Active';
    };

    window.saveEmployee = async function() {
      const form = document.getElementById('employeeForm');
      const saveBtn = document.getElementById('saveEmployeeBtn');
      const btnText = saveBtn.querySelector('.btn-text');
      const spinner = saveBtn.querySelector('.spinner-border');
      
      document.querySelectorAll('.form-control, .form-select').forEach(el => {
        el.classList.remove('is-invalid');
      });

      const requiredFields = [
        { id: 'emp-fname', name: 'First Name' },
        { id: 'emp-lname', name: 'Last Name' },
        { id: 'emp-office', name: 'Office' },
        { id: 'emp-position', name: 'Position' },
        { id: 'emp-status', name: 'Status' }
      ];

      let hasErrors = false;
      requiredFields.forEach(field => {
        const element = document.getElementById(field.id);
        if (!element.value || element.value.trim() === '') {
          element.classList.add('is-invalid');
          hasErrors = true;
        }
      });

      if (hasErrors) {
        return;
      }

      const isUpdate = document.getElementById('emp-id-hidden').value !== '';
      const employeeId = document.getElementById('emp-id-hidden').value;
      const statusValue = document.getElementById('emp-status').value;
      
      const data = {
        firstName: document.getElementById('emp-fname').value,
        lastName: document.getElementById('emp-lname').value,
        middleName: document.getElementById('emp-mname').value,
        suffix: document.getElementById('emp-suffix').value,
        office: document.getElementById('emp-office').value,
        position: document.getElementById('emp-position').value,
        isActive: statusValue === 'Active'
      };

      try {
        saveBtn.disabled = true;
        btnText.classList.add('d-none');
        spinner.classList.remove('d-none');

        const result = await new Promise((resolve, reject) => {
          if (isUpdate) {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .updateEmployee_SERVER(employeeId, data);
          } else {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .addEmployee_SERVER(data);
          }
        });

        if (result.success) {
          const title = isUpdate ? 'Employee Updated!' : 'Employee Added!';
          const message = isUpdate 
            ? 'Employee information updated successfully.' 
            : `Employee ID: ${result.employeeId}`;
          Modal.success(title, message);
          bootstrap.Modal.getInstance(document.getElementById('employeeModal')).hide();
          form.reset();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving employee: ' + error);
      } finally {
        saveBtn.disabled = false;
        btnText.classList.remove('d-none');
        spinner.classList.add('d-none');
      }
    };

    window.editEmployee = function(employeeId) {
      const emp = employeesData.find(e => e.employeeId === employeeId);
      if (!emp) return;

      document.getElementById('emp-id-hidden').value = employeeId;
      document.getElementById('emp-id-text').textContent = employeeId;
      document.getElementById('emp-id-display').style.display = 'block';
      document.getElementById('emp-fname').value = emp.firstName;
      document.getElementById('emp-mname').value = emp.middleName || '';
      document.getElementById('emp-lname').value = emp.lastName;
      document.getElementById('emp-suffix').value = emp.suffix || '';
      document.getElementById('emp-office').value = emp.office;
      document.getElementById('emp-position').value = emp.position;
      document.getElementById('emp-status').value = emp.isActive ? 'Active' : 'Inactive';
      
      document.getElementById('employeeModalTitle').textContent = 'Edit Employee';
      
      new bootstrap.Modal(document.getElementById('employeeModal')).show();
    };

    window.resetHolidayForm = function() {
      document.getElementById('holidayForm').reset();
    };

    window.saveHoliday = async function() {
      const form = document.getElementById('holidayForm');
      if (!form.checkValidity()) {
        form.reportValidity();
        return;
      }

      const data = {
        date: document.getElementById('hol-date').value,
        name: document.getElementById('hol-name').value,
        type: document.getElementById('hol-type').value,
        isRecurring: document.getElementById('hol-recurring').checked
      };

      try {
        const result = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .addHoliday_SERVER(data);
        });

        if (result.success) {
          Modal.success('Success!', 'Holiday added successfully!');
          bootstrap.Modal.getInstance(document.getElementById('holidayModal')).hide();
          form.reset();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error adding holiday: ' + error);
      }
    };

    window.deleteHoliday = async function(holidayId) {
      Modal.confirm(
        'Delete Holiday',
        'Are you sure you want to delete this holiday? This action cannot be undone.',
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteHoliday_SERVER(holidayId);
            });

            if (result.success) {
              Modal.success('Success!', 'Holiday deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting holiday: ' + error);
          }
        }
      );
    };

    document.addEventListener('DOMContentLoaded', () => {
      initFirebase();

      // Lazy rendering for employee tabs - only render when tab is shown
      document.querySelector('a[href="#active-employees-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderEmployeesTable('active');
      });

      document.querySelector('a[href="#inactive-employees-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderEmployeesTable('inactive');
      });

      // Lazy rendering for library tabs - only render when tab is shown
      document.querySelector('a[href="#offices-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderLibraryTable('offices');
      });

      document.querySelector('a[href="#positions-tab"]')?.addEventListener('shown.bs.tab', function() {
        renderLibraryTable('positions');
      });

      // Fix for Bootstrap tabs not firing correctly on first click
      document.querySelectorAll('#employeeTabs a[data-bs-toggle="tab"], #libraryTabs a[data-bs-toggle="tab"]').forEach(tabEl => {
        tabEl.addEventListener('click', function (event) {
          event.preventDefault(); // Ensure default href jump is stopped
          try {
            // 'this' is the clicked a[data-bs-toggle="tab"]
            const tab = new bootstrap.Tab(this);
            tab.show();
          } catch (e) {
            console.error('Error showing tab:', e);
          }
        });
      });

      // Fix dropdown hover state persistence
      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', function() {
          this.blur();
          // Close the dropdown
          const dropdown = this.closest('.dropdown');
          if (dropdown) {
            const toggle = dropdown.querySelector('[data-bs-toggle="dropdown"]');
            if (toggle) {
              bootstrap.Dropdown.getInstance(toggle)?.hide();
            }
          }
        });
      });
    });

    window.showAddLibraryModal = function(type) {
      document.getElementById('lib-item-id').value = '';
      document.getElementById('lib-type').value = type;
      document.getElementById('lib-name').value = '';
      
      const typeName = type === 'offices' ? 'Office' : 'Position';
      document.getElementById('libraryModalTitle').textContent = `Add ${typeName}`;
      document.getElementById('libraryItemLabel').textContent = `${typeName} Name`;
      
      new bootstrap.Modal(document.getElementById('libraryModal')).show();
    };

    window.editLibraryItem = function(type, itemId, currentName) {
      document.getElementById('lib-item-id').value = itemId;
      document.getElementById('lib-type').value = type;
      document.getElementById('lib-name').value = currentName;
      
      const typeName = type === 'offices' ? 'Office' : 'Position';
      document.getElementById('libraryModalTitle').textContent = `Edit ${typeName}`;
      document.getElementById('libraryItemLabel').textContent = `${typeName} Name`;
      
      new bootstrap.Modal(document.getElementById('libraryModal')).show();
    };

    window.saveLibraryItem = async function() {
      const form = document.getElementById('libraryForm');
      if (!form.checkValidity()) {
        form.reportValidity();
        return;
      }

      const itemId = document.getElementById('lib-item-id').value;
      const type = document.getElementById('lib-type').value;
      const name = document.getElementById('lib-name').value;

      try {
        const isUpdate = itemId !== '';
        const result = await new Promise((resolve, reject) => {
          if (isUpdate) {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .updateLibraryItem_SERVER(type, itemId, { name });
          } else {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .addLibraryItem_SERVER(type, { name });
          }
        });

        if (result.success) {
          const title = isUpdate ? 'Item Updated!' : 'Item Added!';
          Modal.success(title, isUpdate ? 'Item updated successfully!' : 'Item added successfully!');
          bootstrap.Modal.getInstance(document.getElementById('libraryModal')).hide();
          form.reset();
        } else {
          Modal.error('Error', result.error);
        }
      } catch (error) {
        Modal.error('Error', 'Error saving item: ' + error);
      }
    };

    window.deleteLibraryItem = async function(type, itemId, itemName) {
      Modal.confirm(
        'Delete Item',
        `Are you sure you want to delete "${itemName}"? This action cannot be undone.`,
        async function() {
          try {
            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteLibraryItem_SERVER(type, itemId);
            });

            if (result.success) {
              Modal.success('Success!', 'Item deleted successfully!');
            } else {
              Modal.error('Error', result.error);
            }
          } catch (error) {
            Modal.error('Error', 'Error deleting item: ' + error);
          }
        }
      );
    };

    // Fix for active state on page navigation
    document.querySelectorAll('a[data-page]').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const page = this.dataset.page;

        document.querySelectorAll('.page-view').forEach(p => p.classList.remove('active'));
        document.getElementById(`page-${page}`).classList.add('active');

        // Remove active class from ALL nav links first
        document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));

        // Add active class to the clicked link
        this.classList.add('active');

        // Check if the link is inside a dropdown
        const dropdownMenu = this.closest('.dropdown-menu');
        if (dropdownMenu) {
          // If it is, add 'active' to the dropdown toggle as well
          const dropdownToggle = dropdownMenu.previousElementSibling;
          if (dropdownToggle && dropdownToggle.classList.contains('dropdown-toggle')) {
            dropdownToggle.classList.add('active');
          }
        }

        // Set default active tabs for Employees and Libraries pages
        if (page === 'employees') {
          // Activate the "Active Employees" tab
          const activeTab = document.querySelector('a[href="#active-employees-tab"]');
          if (activeTab) {
            const tab = new bootstrap.Tab(activeTab);
            tab.show();
          }
        } else if (page === 'libraries') {
          // Activate the "Offices" tab
          const officesTab = document.querySelector('a[href="#offices-tab"]');
          if (officesTab) {
            const tab = new bootstrap.Tab(officesTab);
            tab.show();
          }
        }
      });
    });
  </script>
